<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/apt/index.apt at 2019-10-10 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Waarp All &#x2013; </title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<a href="http://www.waarp.fr" id="bannerLeft"><img src="images/waarp.jpg"  alt="Waarp Project"/></a>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2019-10-10</span>
          &nbsp;| <span id="projectVersion">Version: 3.2.0</span>
      </div>
      <div class="xright"><a href="http://www.waarp.fr/" class="externalLink" title="Waarp">Waarp</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Waarp All</h5>
    <ul>
     <li class="none"><strong>Overview of Waarp All Server</strong></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="WaarpDigest/index.html" title="Waarp Digest">Waarp Digest</a></li>
     <li class="none"><a href="WaarpCommon/index.html" title="Waarp Common">Waarp Common</a></li>
     <li class="none"><a href="WaarpExec/index.html" title="Waarp Exec">Waarp Exec</a></li>
     <li class="none"><a href="WaarpSnmp/index.html" title="Waarp Snmp">Waarp Snmp</a></li>
     <li class="none"><a href="WaarpThrift/index.html" title="Waarp Thrift">Waarp Thrift</a></li>
     <li class="none"><a href="WaarpPassword/index.html" title="Waarp Password Management GUI and Console">Waarp Password Management GUI and Console</a></li>
     <li class="none"><a href="WaarpFtp/index.html" title="Waarp Ftp">Waarp Ftp</a></li>
     <li class="none"><a href="WaarpFtpClient/index.html" title="Waarp Ftp R66 client">Waarp Ftp R66 client</a></li>
     <li class="none"><a href="WaarpGatewayKernel/index.html" title="Waarp Gateway Kernel">Waarp Gateway Kernel</a></li>
     <li class="none"><a href="WaarpR66/index.html" title="Waarp OpenR66">Waarp OpenR66</a></li>
     <li class="none"><a href="WaarpGatewayFtp/index.html" title="Waarp Gateway Ftp">Waarp Gateway Ftp</a></li>
     <li class="none"><a href="WaarpProxyR66/index.html" title="Waarp Proxy in R66 protocol">Waarp Proxy in R66 protocol</a></li>
     <li class="none"><a href="WaarpR66Gui/index.html" title="Waarp R66 Client Gui">Waarp R66 Client Gui</a></li>
     <li class="none"><a href="WaarpAdministrator/index.html" title="Waarp Administrator">Waarp Administrator</a></li>
     <li class="none"><a href="WaarpXmlEditor/index.html" title="Waarp XMLEditor">Waarp XMLEditor</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="expanded"><a href="project-info.html" title="Project Information">Project Information</a>
      <ul>
       <li class="none"><strong>About</strong></li>
       <li class="none"><a href="summary.html" title="Summary">Summary</a></li>
       <li class="none"><a href="dependency-convergence.html" title="Dependency Convergence">Dependency Convergence</a></li>
       <li class="none"><a href="dependency-info.html" title="Dependency Information">Dependency Information</a></li>
       <li class="none"><a href="dependency-management.html" title="Dependency Management">Dependency Management</a></li>
       <li class="none"><a href="modules.html" title="Project Modules">Project Modules</a></li>
       <li class="none"><a href="issue-management.html" title="Issue Management">Issue Management</a></li>
       <li class="none"><a href="licenses.html" title="Licenses">Licenses</a></li>
       <li class="none"><a href="team.html" title="Team">Team</a></li>
       <li class="none"><a href="plugins.html" title="Plugins">Plugins</a></li>
       <li class="none"><a href="plugin-management.html" title="Plugin Management">Plugin Management</a></li>
       <li class="none"><a href="scm.html" title="Source Code Management">Source Code Management</a></li>
      </ul></li>
     <li class="collapsed"><a href="project-reports.html" title="Project Reports">Project Reports</a></li>
    </ul>
      <a href="https://www.waarp.fr/" title="Waarp" class="poweredBy">
        <img class="poweredBy"  alt="Waarp" src="https://www.waarp.fr/i/logo.png"     />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<div class="section">

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>

<h1 id="codeanalysis">SonarQube Code analysis</h1>
<h2 id="waarp-all">Waarp All</h2>
<h4 id="version-3-2-0">Version 3.2.0</h4>
<p><strong>By: Frédéric Brégier</strong></p>
<p><em>Date: 2019-10-10</em></p>
<h2 id="introduction">Introduction</h2>
<p>This document contains results of the code analysis of Waarp All</p>
<h2 id="synthesis">Synthesis</h2>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky" style="text-align:center">Quality Gate</th>
<th class="tg-0pky" style="text-align:center">Reliability</th>
<th class="tg-0pky" style="text-align:center">Security</th>
<th class="tg-0pky" style="text-align:center">Maintainability</th>
<th class="tg-0pky" style="text-align:center">Coverage</th>
<th class="tg-0pky" style="text-align:center">Duplications</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky" style="text-align:center">WARN</td>
<td class="tg-0pky" style="text-align:center">D</td>
<td class="tg-0pky" style="text-align:center">B</td>
<td class="tg-0pky" style="text-align:center">A</td>
<td class="tg-0pky" style="text-align:center">41.1 %</td>
<td class="tg-0pky" style="text-align:center">8.4 %</td>
</tr>
</tbody>
</table>
<h2 id="metrics">Metrics</h2>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky" class="tg-0pky" style="text-align:left">\</th>
<th class="tg-0pky" style="text-align:center">Cyclomatic Complexity</th>
<th class="tg-0pky" style="text-align:center">Cognitive Complexity</th>
<th class="tg-0pky" style="text-align:center">Lines of code per file</th>
<th class="tg-0pky" style="text-align:center">Coverage</th>
<th class="tg-0pky" style="text-align:center">Comment density (%)</th>
<th class="tg-0pky" style="text-align:center">Duplication (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky" style="text-align:left">Min</td>
<td class="tg-0pky" style="text-align:center">0.0</td>
<td class="tg-0pky" style="text-align:center">0.0</td>
<td class="tg-0pky" style="text-align:center">1.0</td>
<td class="tg-0pky" style="text-align:center">0.0</td>
<td class="tg-0pky" style="text-align:center">0.0</td>
<td class="tg-0pky" style="text-align:center">0.0</td>
</tr>
<tr>
<td class="tg-0pky" style="text-align:left">Max</td>
<td class="tg-0pky" style="text-align:center">9132.0</td>
<td class="tg-0pky" style="text-align:center">11973.0</td>
<td class="tg-0pky" style="text-align:center">56671.0</td>
<td class="tg-0pky" style="text-align:center">100.0</td>
<td class="tg-0pky" style="text-align:center">99.4</td>
<td class="tg-0pky" style="text-align:center">68.7</td>
</tr>
</tbody>
</table>
<h2 id="volume">Volume</h2>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky">Language</th>
<th class="tg-0pky">Number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky">Java</td>
<td class="tg-0pky">117337</td>
</tr>
<tr>
<td class="tg-0pky">Total</td>
<td class="tg-0pky">117337</td>
</tr>
</tbody>
</table>
<h2 id="issues-count-by-severity-and-types">Issues count by severity and types</h2>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky">Type</th>
<th class="tg-0pky">Severity</th>
<th class="tg-0pky">Number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">BLOCKER</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">280</td>
</tr>
<tr>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">BLOCKER</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">4</td>
</tr>
<tr>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">64</td>
</tr>
<tr>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">68</td>
</tr>
<tr>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">BLOCKER</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">194</td>
</tr>
<tr>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1684</td>
</tr>
<tr>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">871</td>
</tr>
<tr>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">17</td>
</tr>
<tr>
<td class="tg-0pky">SECURITY_HOTSPOT</td>
<td class="tg-0pky">BLOCKER</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">SECURITY_HOTSPOT</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">SECURITY_HOTSPOT</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">SECURITY_HOTSPOT</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">0</td>
</tr>
<tr>
<td class="tg-0pky">SECURITY_HOTSPOT</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">0</td>
</tr>
</tbody>
</table>
<h2 id="issues">Issues</h2>
<table class="tg">
<thead>
<tr>
<th class="tg-0pky">Name</th>
<th class="tg-0pky">Description</th>
<th class="tg-0pky">Type</th>
<th class="tg-0pky">Severity</th>
<th class="tg-0pky">Number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0pky">Jump statements should not occur in &quot;finally&quot; blocks</td>
<td class="tg-0pky">Using return, break, throw, and so on from a finally block suppresses the propagation of any <br /> unhandled Throwable which was thrown in the try or catch block. <br /> This rule raises an issue when a jump statement (break, continue, return, throw, and <br /> goto) would force control flow to leave a finally block.  <br /> Noncompliant Code Example <br />  <br /> public static void main(String[] args) { <br />   try { <br />     doSomethingWhichThrowsException(); <br />     System.out.println(&quot;OK&quot;);   // incorrect &quot;OK&quot; message is printed <br />   } catch (RuntimeException e) { <br />     System.out.println(&quot;ERROR&quot;);  // this message is not shown <br />   } <br /> } <br />  <br /> public static void doSomethingWhichThrowsException() { <br />   try { <br />     throw new RuntimeException(); <br />   } finally { <br />     for (int i = 0; i &lt; 10; i ++) { <br />       //... <br />       if (q == i) { <br />         break; // ignored <br />       } <br />     } <br />  <br />     /<em> ... </em>/ <br />     return;      // Noncompliant - prevents the RuntimeException from being propagated <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public static void main(String[] args) { <br />   try { <br />     doSomethingWhichThrowsException(); <br />     System.out.println(&quot;OK&quot;); <br />   } catch (RuntimeException e) { <br />     System.out.println(&quot;ERROR&quot;);  // &quot;ERROR&quot; is printed as expected <br />   } <br /> } <br />  <br /> public static void doSomethingWhichThrowsException() { <br />   try { <br />     throw new RuntimeException(); <br />   } finally { <br />     for (int i = 0; i &lt; 10; i ++) { <br />       //... <br />       if (q == i) { <br />         break; // ignored <br />       } <br />     } <br />  <br />     /<em> ... </em>/ <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-584 - Return Inside Finally Block  <br />    CERT, ERR04-J. - Do not complete abruptly from a finally block  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">4</td>
</tr>
<tr>
<td class="tg-0pky">&quot;equals&quot; method overrides should accept &quot;Object&quot; parameters</td>
<td class="tg-0pky">&quot;equals&quot; as a method name should be used exclusively to override Object.equals(Object) to prevent any confusion. <br /> It is tempting to overload the method to take a specific class instead of Object as parameter, to save the class comparison check. <br /> However, this will not work as expected when that is the only override. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />   private int foo = 1; <br />  <br />   public boolean equals(MyClass o) {  // Noncompliant; does not override Object.equals(Object) <br />     return o != null &amp;&amp; o.foo == this.foo; <br />   } <br />  <br />   public static void main(String[] args) { <br />     MyClass o1 = new MyClass(); <br />     Object o2 = new MyClass(); <br />     System.out.println(o1.equals(o2));  // Prints &quot;false&quot; because o2 an Object not a MyClass <br />   } <br /> } <br />  <br /> class MyClass2 { <br />   public boolean equals(MyClass2 o) {  // Ignored; <code>boolean equals(Object)</code> also present <br />     //.. <br />   } <br />  <br />   public boolean equals(Object o) { <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />   private int foo = 1; <br />  <br />   @Override <br />   public boolean equals(Object o) { <br />     if (this == o) { <br />         return true; <br />     } <br />     if (o == null &amp;#124&amp;#124 getClass() != o.getClass()) { <br />       return false; <br />     } <br />  <br />     MyClass other = (MyClass)o; <br />     return this.foo == other.foo; <br />   } <br />  <br />   /<em> ... </em>/ <br /> } <br />  <br /> class MyClass2 { <br />   public boolean equals(MyClass2 o) { <br />     //.. <br />   } <br />  <br />   public boolean equals(Object o) { <br />     //... <br />   } <br /> } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;Thread.run()&quot; should not be called directly</td>
<td class="tg-0pky">The purpose of the Thread.run() method is to execute code in a separate, dedicated thread. Calling this method directly doesn&#39;t make <br /> sense because it causes its code to be executed in the current thread.  <br /> To get the expected behavior, call the Thread.start() method instead. <br /> Noncompliant Code Example <br />  <br /> Thread myThread = new Thread(runnable); <br /> myThread.run(); // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> Thread myThread = new Thread(runnable); <br /> myThread.start(); // Compliant <br />  <br /> See <br />  <br />    MITRE, CWE-572 - Call to Thread run() instead of start()  <br />    CERT THI00-J. - Do not invoke Thread.run()  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Methods should not be named &quot;tostring&quot;, &quot;hashcode&quot; or &quot;equal&quot;</td>
<td class="tg-0pky">Naming a method tostring, hashcode() or equal is either: <br />  <br />    A bug in the form of a typo. Overriding toString, Object.hashCode() (note the camelCasing) or <br />   Object.equals (note the &#39;s&#39; on the end) was meant, and the application does not behave as expected.  <br />    Done on purpose. The name however will confuse every other developer, who may not notice the naming difference, or who will think it is a bug. <br />    <br />  <br /> In both cases, the method should be renamed. <br /> Noncompliant Code Example <br />  <br /> public int hashcode() { /<em> ... </em>/ }  // Noncompliant <br />  <br /> public String tostring() { /<em> ... </em>/ } // Noncompliant <br />  <br /> public boolean equal(Object obj) { /<em> ... </em>/ }  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public int hashCode() { /<em> ... </em>/ } <br />  <br /> @Override <br /> public String toString() { /<em> ... </em>/ } <br />  <br /> @Override <br /> public boolean equals(Object obj) { /<em> ... </em>/ } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Classes extending java.lang.Thread should override the &quot;run&quot; method</td>
<td class="tg-0pky">According to the Java API documentation: <br />  <br />   There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the <br />   run method of class Thread. An instance of the subclass can then be allocated and started... <br />   The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An <br />   instance of the class can then be allocated, passed as an argument when creating Thread, and started. <br />  <br /> By definition, extending the Thread class without overriding the run method doesn&#39;t make sense, and implies that the contract of the <br /> Thread class is not well understood. <br /> Noncompliant Code Example <br />  <br /> public class MyRunner extends Thread { // Noncompliant; run method not overridden <br />  <br />   public void doSometing() {...} <br /> } <br />  <br /> Exceptions <br /> If run() is not overridden in a class extending Thread, it means that starting the thread will actually call <br /> Thread.run(). However, Thread.run() does nothing if it has not been fed with a target Runnable. The rule <br /> consequently ignore classes extending Thread if they are calling, in their constructors, the super(...) constructor with a <br /> proper Runnable target. <br />  <br /> class MyThread extends Thread { // Compliant - calling super constructor with a Runnable <br />   MyThread(Runnable target) { <br />     super(target); // calling super constructor with a Runnable, which will be used for when Thread.run() is executed <br />     // ... <br />   } <br /> } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Child class methods named for parent class methods should be overrides</td>
<td class="tg-0pky">When a method in a child class has the same signature as a method in a parent class, it is assumed to be an override. However, that&#39;s not the case <br /> when: <br />  <br />    the parent class method is static and the child class method is not.  <br />    the arguments or return types of the child method are in different packages than those of the parent method.  <br />    the parent class method is private.  <br />  <br /> Typically, these things are done unintentionally; the private parent class method is overlooked, the static keyword in the parent <br /> declaration is overlooked, or the wrong class is imported in the child. But if the intent is truly for the child class method to be different, then <br /> the method should be renamed to prevent confusion.  <br /> Noncompliant Code Example <br />  <br /> // Parent.java <br /> import computer.Pear; <br /> public class Parent { <br />  <br />   public void doSomething(Pear p) { <br />     //,,, <br />   } <br />  <br />   public static void doSomethingElse() { <br />     //... <br />   } <br /> } <br />  <br /> // Child.java <br /> import fruit.Pear; <br /> public class Child extends Parent { <br />  <br />   public void doSomething(Pear p) {  // Noncompliant; this is not an override <br />     // ... <br />   } <br />  <br />  <br />   public void doSomethingElse() {  // Noncompliant; parent method is static <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> // Parent.java <br /> import computer.Pear; <br /> public class Parent { <br />  <br />   public void doSomething(Pear p) { <br />     //,,, <br />   } <br />  <br />   public static void doSomethingElse() { <br />     //... <br />   } <br /> } <br />  <br /> // Child.java <br /> import computer.Pear;  // import corrected <br /> public class Child extends Parent { <br />  <br />   public void doSomething(Pear p) {  // true override (see import) <br />     //,,, <br />   } <br />  <br />   public static void doSomethingElse() { <br />     //... <br />   } <br /> } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">15</td>
</tr>
<tr>
<td class="tg-0pky">Null pointers should not be dereferenced</td>
<td class="tg-0pky">A reference to null should never be dereferenced/accessed. Doing so will cause a NullPointerException to be thrown. At <br /> best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or <br /> it could allow an attacker to bypass security measures. <br /> Note that when they are present, this rule takes advantage of @CheckForNull and @Nonnull annotations defined in JSR-305 to understand which values are and are not nullable except when @Nonnull is used <br /> on the parameter to equals, which by contract should always work with null. <br /> Noncompliant Code Example <br />  <br /> @CheckForNull <br /> String getName(){...} <br />  <br /> public boolean isNameEmpty() { <br />   return getName().length() == 0; // Noncompliant; the result of getName() could be null, but isn&#39;t null-checked <br /> } <br />  <br />  <br /> Connection conn = null; <br /> Statement stmt = null; <br /> try{ <br />   conn = DriverManager.getConnection(DB_URL,USER,PASS); <br />   stmt = conn.createStatement(); <br />   // ... <br />  <br /> }catch(Exception e){ <br />   e.printStackTrace(); <br /> }finally{ <br />   stmt.close();   // Noncompliant; stmt could be null if an exception was thrown in the try{} block <br />   conn.close();  // Noncompliant; conn could be null if an exception was thrown <br /> } <br />  <br />  <br /> private void merge(@Nonnull Color firstColor, @Nonnull Color secondColor){...} <br />  <br /> public  void append(@CheckForNull Color color) { <br />     merge(currentColor, color);  // Noncompliant; color should be null-checked because merge(...) doesn&#39;t accept nullable parameters <br /> } <br />  <br />  <br /> void paint(Color color) { <br />   if(color == null) { <br />     System.out.println(&quot;Unable to apply color &quot; + color.toString());  // Noncompliant; NullPointerException will be thrown <br />     return; <br />   } <br />   ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-476 - NULL Pointer Dereference  <br />    CERT, EXP34-C. - Do not dereference null pointers  <br />    CERT, EXP01-J. - Do not use a null in a case where an object is required <br />    <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">29</td>
</tr>
<tr>
<td class="tg-0pky">Blocks should be synchronized on &quot;private final&quot; fields</td>
<td class="tg-0pky">Synchronizing on a class field synchronizes not on the field itself, but on the object assigned to it. So synchronizing on a non-final <br /> field makes it possible for the field&#39;s value to change while a thread is in a block synchronized on the old value. That would allow a second thread, <br /> synchronized on the new value, to enter the block at the same time. <br /> The story is very similar for synchronizing on parameters; two different threads running the method in parallel could pass two different object <br /> instances in to the method as parameters, completely undermining the synchronization. <br /> Noncompliant Code Example <br />  <br /> private String color = &quot;red&quot;; <br />  <br /> private void doSomething(){ <br />   synchronized(color) {  // Noncompliant; lock is actually on object instance &quot;red&quot; referred to by the color variable <br />     //... <br />     color = &quot;green&quot;; // other threads now allowed into this block <br />     // ... <br />   } <br />   synchronized(new Object()) { // Noncompliant this is a no-op. <br />      // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> private String color = &quot;red&quot;; <br /> private final Object lockObj = new Object(); <br />  <br /> private void doSomething(){ <br />   synchronized(lockObj) { <br />     //... <br />     color = &quot;green&quot;; <br />     // ... <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-412 - Unrestricted Externally Accessible Lock  <br />    MITRE, CWE-413 - Improper Resource Locking  <br />    CERT, LCK00-J. - Use private final lock objects to synchronize classes that <br />   may interact with untrusted code  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Conditionally executed blocks should be reachable</td>
<td class="tg-0pky">Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never <br /> be used in production. <br /> Noncompliant Code Example <br />  <br /> a = false; <br /> if (a) { // Noncompliant <br />   doSomething(); // never executed <br /> } <br />  <br /> if (!a &amp;#124&amp;#124 b) { // Noncompliant; &quot;!a&quot; is always &quot;true&quot;, &quot;b&quot; is never evaluated <br />   doSomething(); <br /> } else { <br />   doSomethingElse(); // never executed <br /> } <br />  <br /> Exceptions <br /> This rule will not raise an issue in either of these cases: <br />  <br />    When the condition is a single final boolean  <br />  <br />  <br /> final boolean debug = false; <br /> //... <br /> if (debug) { <br />   // Print something <br /> } <br />  <br />  <br />    When the condition is literally true or false.  <br />  <br />  <br /> if (true) { <br />   // do something <br /> } <br />  <br /> In these cases it is obvious the code is as intended. <br /> See <br />  <br />    MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted.  <br />    MISRA C:2012, 14.3 - Controlling expressions shall not be invariant  <br />    MITRE, CWE-570 - Expression is Always False  <br />    MITRE, CWE-571 - Expression is Always True  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">10</td>
</tr>
<tr>
<td class="tg-0pky">Non-thread-safe fields should not be static</td>
<td class="tg-0pky">Not all classes in the standard Java library were written to be thread-safe. Using them in a multi-threaded manner is highly likely to cause data <br /> problems or exceptions at runtime. <br /> This rule raises an issue when an instance of Calendar, DateFormat, javax.xml.xpath.XPath, or <br /> javax.xml.validation.SchemaFactory is marked static. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private static SimpleDateFormat format = new SimpleDateFormat(&quot;HH-mm-ss&quot;);  // Noncompliant <br />   private static Calendar calendar = Calendar.getInstance();  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   private SimpleDateFormat format = new SimpleDateFormat(&quot;HH-mm-ss&quot;); <br />   private Calendar calendar = Calendar.getInstance(); <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">&quot;volatile&quot; variables should not be used with compound operators</td>
<td class="tg-0pky">Using compound operators as well as increments and decrements (and toggling, in the case of booleans) on primitive fields are not <br /> atomic operations. That is, they don&#39;t happen in a single step. For instance, when a volatile primitive field is incremented or <br /> decremented you run the risk of data loss if threads interleave in the steps of the update. Instead, use a guaranteed-atomic class such as <br /> AtomicInteger, or synchronize the access. <br /> Noncompliant Code Example <br />  <br /> private volatile int count = 0; <br /> private volatile boolean boo = false; <br />  <br /> public void incrementCount() { <br />   count++;  // Noncompliant <br /> } <br />  <br /> public void toggleBoo(){ <br />   boo = !boo;  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> private AtomicInteger count = 0; <br /> private boolean boo = false; <br />  <br /> public void incrementCount() { <br />   count.incrementAndGet(); <br /> } <br />  <br /> public synchronized void toggleBoo() { <br />   boo = !boo; <br /> } <br />  <br /> See <br />  <br />    CERT, VNA02-J. - Ensure that compound operations on shared variables are <br />   atomic  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Boxing and unboxing should not be immediately reversed</td>
<td class="tg-0pky">Boxing is the process of putting a primitive value into an analogous object, such as creating an Integer to hold an int <br /> value. Unboxing is the process of retrieving the primitive value from such an object. <br /> Since the original value is unchanged during boxing and unboxing, there&#39;s no point in doing either when not needed. This also applies to autoboxing <br /> and auto-unboxing (when Java implicitly handles the primitive/object transition for you). <br /> Noncompliant Code Example <br />  <br /> public void examineInt(int a) { <br />   //... <br /> } <br />  <br /> public void examineInteger(Integer a) { <br />   // ... <br /> } <br />  <br /> public void func() { <br />   int i = 0; <br />   Integer iger1 = Integer.valueOf(0); <br />   double d = 1.0; <br />  <br />   int dIntValue = new Double(d).intValue(); // Noncompliant <br />  <br />   examineInt(new Integer(i).intValue()); // Noncompliant; explicit box/unbox <br />   examineInt(Integer.valueOf(i));  // Noncompliant; boxed int will be auto-unboxed <br />  <br />   examineInteger(i); // Compliant; value is boxed but not then unboxed <br />   examineInteger(iger1.intValue()); // Noncompliant; unboxed int will be autoboxed <br />  <br />   Integer iger2 = new Integer(iger1); // Noncompliant; unnecessary unboxing, value can be reused <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void examineInt(int a) { <br />   //... <br /> } <br />  <br /> public void examineInteger(Integer a) { <br />   // ... <br /> } <br />  <br /> public void func() { <br />   int i = 0; <br />   Integer iger1 = Integer.valueOf(0); <br />   double d = 1.0; <br />  <br />   int dIntValue = (int) d; <br />  <br />   examineInt(i); <br />  <br />   examineInteger(i); <br />   examineInteger(iger1); <br /> } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">8</td>
</tr>
<tr>
<td class="tg-0pky">Math operands should be cast before assignment</td>
<td class="tg-0pky">When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long, <br /> double, or float with automatic type conversion, but having started as an int or long, the result <br /> will likely not be what you expect.  <br /> For instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the <br /> assignment. Likewise, if the result of multiplication is assigned to a long, it may have already overflowed before the assignment. <br /> In either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the <br /> operation takes place. <br /> Noncompliant Code Example <br />  <br /> float twoThirds = 2/3; // Noncompliant; int division. Yields 0.0 <br /> long millisInYear = 1_000<em>3_600</em>24<em>365; // Noncompliant; int multiplication. Yields 1471228928 <br /> long bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647 <br /> long bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one. <br /> Date myDate = new Date(seconds </em> 1_000); //Noncompliant, won&#39;t produce the expected result if seconds &gt; 2_147_483 <br /> ... <br /> public long compute(int factor){ <br />   return factor <em> 10_000;  //Noncompliant, won&#39;t produce the expected result if factor &gt; 214_748 <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123;  //Noncompliant, will be rounded to closest long integer <br /> } <br />  <br /> Compliant Solution <br />  <br /> float twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667 <br /> long millisInYear = 1_000L</em>3_600<em>24</em>365; // 1000 promoted to long. Yields 31_536_000_000 <br /> long bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649 <br /> long bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649 <br /> Date myDate = new Date(seconds <em> 1_000L); <br /> ... <br /> public long compute(int factor){ <br />   return factor </em> 10_000L; <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123f; <br /> } <br />  <br /> or <br />  <br /> float twoThirds = (float)2/3; // 2 cast to float <br /> long millisInYear = (long)1_000<em>3_600</em>24<em>365; // 1_000 cast to long <br /> long bigNum = (long)Integer.MAX_VALUE + 2; <br /> long bigNegNum =  (long)Integer.MIN_VALUE-1; <br /> Date myDate = new Date((long)seconds </em> 1_000); <br /> ... <br /> public long compute(long factor){ <br />   return factor * 10_000; <br /> } <br />  <br /> public float compute2(float factor){ <br />   return factor / 123; <br /> } <br />  <br /> See <br />  <br />    MISRA C++:2008, 5-0-8 - An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue <br />   expression.  <br />    MITRE, CWE-190 - Integer Overflow or Wraparound  <br />    CERT, NUM50-J. - Convert integers to floating point for floating-point <br />   operations  <br />    CERT, INT18-C. - Evaluate integer expressions in a larger size before <br />   comparing or assigning to that size  <br />    SANS Top 25 - Risky Resource Management  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">7</td>
</tr>
<tr>
<td class="tg-0pky">Neither &quot;Math.abs&quot; nor negation should be used on numbers that could be &quot;MIN_VALUE&quot;</td>
<td class="tg-0pky">It is possible for a call to hashCode to return Integer.MIN_VALUE. Take the absolute value of such a hashcode and you&#39;ll <br /> still have a negative number. Since your code is likely to assume that it&#39;s a positive value instead, your results will be unreliable. <br /> Similarly, Integer.MIN_VALUE could be returned from Random.nextInt() or any object&#39;s compareTo method, and <br /> Long.MIN_VALUE could be returned from Random.nextLong(). Calling Math.abs on values returned from these methods <br /> is similarly ill-advised. <br /> Noncompliant Code Example <br />  <br /> public void doSomething(String str) { <br />   if (Math.abs(str.hashCode()) &gt; 0) { // Noncompliant <br />     // ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(String str) { <br />   if (str.hashCode() != 0) { <br />     // ... <br />   } <br /> } <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Non-primitive fields should not be &quot;volatile&quot;</td>
<td class="tg-0pky">Marking an array volatile means that the array itself will always be read fresh and never thread cached, but the items in the <br /> array will not be. Similarly, marking a mutable object field volatile means the object reference is volatile but <br /> the object itself is not, and other threads may not see updates to the object state. <br /> This can be salvaged with arrays by using the relevant AtomicArray class, such as AtomicIntegerArray, instead. For mutable objects, <br /> the volatile should be removed, and some other method should be used to ensure thread-safety, such as synchronization, or ThreadLocal <br /> storage. <br /> Noncompliant Code Example <br />  <br /> private volatile int [] vInts;  // Noncompliant <br /> private volatile MyObj myObj;  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> private AtomicIntegerArray vInts; <br /> private MyObj myObj; <br />  <br /> See <br />  <br />    CERT, CON50-J. - Do not assume that declaring a reference volatile <br />   guarantees safe publication of the members of the referenced object  <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">49</td>
</tr>
<tr>
<td class="tg-0pky">Double Brace Initialization should not be used</td>
<td class="tg-0pky">Because Double Brace Initialization (DBI) creates an anonymous class with a reference to the instance of the owning object, its use can lead to <br /> memory leaks if the anonymous inner class is returned and held by other objects. Even when there&#39;s no leak, DBI is so obscure that it&#39;s bound to <br /> confuse most maintainers.  <br /> For collections, use Arrays.asList instead, or explicitly add each item directly to the collection. <br /> Noncompliant Code Example <br />  <br /> Map source = new HashMap(){{ // Noncompliant <br />     put(&quot;firstName&quot;, &quot;John&quot;); <br />     put(&quot;lastName&quot;, &quot;Smith&quot;); <br /> }}; <br />  <br /> Compliant Solution <br />  <br /> Map source = new HashMap(); <br /> // ... <br /> source.put(&quot;firstName&quot;, &quot;John&quot;); <br /> source.put(&quot;lastName&quot;, &quot;Smith&quot;); <br /> // ... <br /></td>
<td class="tg-0pky">BUG</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Exceptions should not be thrown in finally blocks</td>
<td class="tg-0pky">Throwing an exception from within a finally block will mask any exception which was previously thrown in the try or catch <br /> block, and the masked&#39;s exception message and stack trace will be lost. <br /> Noncompliant Code Example <br />  <br /> try { <br />   /<em> some work which end up throwing an exception </em>/ <br />   throw new IllegalArgumentException(); <br /> } finally { <br />   /<em> clean up </em>/ <br />   throw new RuntimeException();       // Noncompliant; masks the IllegalArgumentException <br /> } <br />  <br /> Compliant Solution <br />  <br /> try { <br />   /<em> some work which end up throwing an exception </em>/ <br />   throw new IllegalArgumentException(); <br /> } finally { <br />   /<em> clean up </em>/ <br /> } <br />  <br /> See <br />  <br />    CERT, ERR05-J. - Do not let checked exceptions escape from a finally block <br />    <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">4</td>
</tr>
<tr>
<td class="tg-0pky">Constants should not be defined in interfaces</td>
<td class="tg-0pky">According to Joshua Bloch, author of &quot;Effective Java&quot;: <br />  <br />   The constant interface pattern is a poor use of interfaces.  <br />   That a class uses some constants internally is an implementation detail. <br />   Implementing a constant interface causes this implementation detail to leak into the class&#39;s exported API. It is of no consequence to the users <br />   of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future <br />   release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. <br />   If a nonfinal class implements a constant interface, <br />   all of its subclasses will have their namespaces polluted by the constants in the interface. <br />  <br /> Noncompliant Code Example <br />  <br /> interface Status {                      // Noncompliant <br />    int OPEN = 1; <br />    int CLOSED = 2; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public enum Status {                    // Compliant <br />   OPEN, <br />   CLOSED; <br /> } <br />  <br /> or <br />  <br /> public final class Status {             // Compliant <br />    public static final int OPEN = 1; <br />    public static final int CLOSED = 2; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Generic wildcard types should not be used in return parameters</td>
<td class="tg-0pky">It is highly recommended not to use wildcard types as return types. Because the type inference rules are fairly complex it is <br /> unlikely the user of that API will know how to use it correctly.  <br /> Let&#39;s take the example of method returning a &quot;List&lt;? extends Animal&gt;&quot;. Is it possible on this list to add a Dog, a Cat, ... we simply don&#39;t <br /> know. And neither does the compiler, which is why it will not allow such a direct use. The use of wildcard types should be limited to method <br /> parameters. <br /> This rule raises an issue when a method returns a wildcard type.  <br /> Noncompliant Code Example <br />  <br /> List&lt;? extends Animal&gt; getAnimals(){...} <br />  <br /> Compliant Solution <br />  <br /> List&lt;Animal&gt; getAnimals(){...} <br />  <br /> or <br />  <br /> List&lt;Dog&gt; getAnimals(){...} <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Fields in a &quot;Serializable&quot; class should either be transient or serializable</td>
<td class="tg-0pky">Fields in a Serializable class must themselves be either Serializable or transient even if the class is <br /> never explicitly serialized or deserialized. For instance, under load, most J2EE application frameworks flush objects to disk, and an allegedly <br /> Serializable object with non-transient, non-serializable data members could cause program crashes, and open the door to attackers. In <br /> general a Serializable class is expected to fulfil its contract and not have an unexpected behaviour when an instance is serialized.  <br /> This rule raises an issue on non-Serializable fields, and on collection fields when they are not private (because they <br /> could be assigned non-Serializable values externally), and when they are assigned non-Serializable types within the <br /> class. <br /> Noncompliant Code Example <br />  <br /> public class Address { <br />   //... <br /> } <br />  <br /> public class Person implements Serializable { <br />   private static final long serialVersionUID = 1905122041950251207L; <br />  <br />   private String name; <br />   private Address address;  // Noncompliant; Address isn&#39;t serializable <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Address implements Serializable { <br />   private static final long serialVersionUID = 2405172041950251807L; <br /> } <br />  <br /> public class Person implements Serializable { <br />   private static final long serialVersionUID = 1905122041950251207L; <br />  <br />   private String name; <br />   private Address address; <br /> } <br />  <br /> Exceptions <br /> The alternative to making all members serializable or transient is to implement special methods which take on the <br /> responsibility of properly serializing and de-serializing the object. This rule ignores classes which implement the following methods: <br />  <br />  private void writeObject(java.io.ObjectOutputStream out) <br />      throws IOException <br />  private void readObject(java.io.ObjectInputStream in) <br />      throws IOException, ClassNotFoundException; <br />  <br /> See <br />  <br />    MITRE, CWE-594 - Saving Unserializable Objects to Disk  <br />    Oracle Java 6, Serializable  <br />    Oracle Java 7, Serializable  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;Cloneables&quot; should implement &quot;clone&quot;</td>
<td class="tg-0pky">Simply implementing Cloneable without also overriding Object.clone() does not necessarily make the class cloneable. While <br /> the Cloneable interface does not include a clone method, it is required by convention, and ensures true cloneability. <br /> Otherwise the default JVM clone will be used, which copies primitive values and object references from the source to the target. I.e. <br /> without overriding clone, any cloned instances will potentially share members with the source instance. <br /> Removing the Cloneable implementation and providing a good copy constructor is another viable (some say preferable) way of allowing a <br /> class to be copied. <br /> Noncompliant Code Example <br />  <br /> class Team implements Cloneable {  // Noncompliant <br />   private Person coach; <br />   private List&lt;Person&gt; players; <br />   public void addPlayer(Person p) {...} <br />   public Person getCoach() {...} <br /> } <br />  <br /> Compliant Solution <br />  <br /> class Team implements Cloneable { <br />   private Person coach; <br />   private List&lt;Person&gt; players; <br />   public void addPlayer(Person p) { ... } <br />   public Person getCoach() { ... } <br />  <br />   @Override <br />   public Object clone() { <br />     Team clone = (Team) super.clone(); <br />     //... <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;indexOf&quot; checks should not be for positive numbers</td>
<td class="tg-0pky">Most checks against an indexOf value compare it with -1 because 0 is a valid index. Any checks which look for values &gt;0 ignore the <br /> first element, which is likely a bug. If the intent is merely to check inclusion of a value in a String or a List, consider <br /> using the contains method instead. <br /> This rule raises an issue when an indexOf value retrieved either from a String or a List is tested against <br /> &gt;0. <br /> Noncompliant Code Example <br />  <br /> String color = &quot;blue&quot;; <br /> String name = &quot;ishmael&quot;; <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt; (); <br /> strings.add(color); <br /> strings.add(name); <br />  <br /> if (strings.indexOf(color) &gt; 0) {  // Noncompliant <br />   // ... <br /> } <br /> if (name.indexOf(&quot;ish&quot;) &gt; 0) { // Noncompliant <br />   // ... <br /> } <br /> if (name.indexOf(&quot;ae&quot;) &gt; 0) { // Noncompliant <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> String color = &quot;blue&quot;; <br /> String name = &quot;ishmael&quot;; <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt; (); <br /> strings.add(color); <br /> strings.add(name); <br />  <br /> if (strings.indexOf(color) &gt; -1) { <br />   // ... <br /> } <br /> if (name.indexOf(&quot;ish&quot;) &gt;= 0) { <br />   // ... <br /> } <br /> if (name.contains(&quot;ae&quot;) { <br />   // ... <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Instance methods should not write to &quot;static&quot; fields</td>
<td class="tg-0pky">Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple <br /> class instances and/or multiple threads in play. Ideally, static fields are only updated from synchronized static <br /> methods. <br /> This rule raises an issue each time a static field is updated from a non-static method. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   private static int count = 0; <br />  <br />   public void doSomething() { <br />     //... <br />     count++;  // Noncompliant <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">35</td>
</tr>
<tr>
<td class="tg-0pky">Cognitive Complexity of methods should not be too high</td>
<td class="tg-0pky">Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be <br /> difficult to maintain. <br /> See <br />  <br />    Cognitive Complexity  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">CRITICAL</td>
<td class="tg-0pky">148</td>
</tr>
<tr>
<td class="tg-0pky">Deprecated code should be removed</td>
<td class="tg-0pky">This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   /<em>* <br />    </em> @deprecated <br />    */ <br />   public void foo() {    // Noncompliant <br />   } <br />  <br />   @Deprecated            // Noncompliant <br />   public void bar() { <br />   } <br />  <br />   public void baz() {    // Compliant <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">7</td>
</tr>
<tr>
<td class="tg-0pky">Track uses of &quot;TODO&quot; tags</td>
<td class="tg-0pky">TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   // TODO <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">INFO</td>
<td class="tg-0pky">10</td>
</tr>
<tr>
<td class="tg-0pky">Source files should not have any duplicated blocks</td>
<td class="tg-0pky">An issue is created on a file as soon as there is at least one block of duplicated code on this file</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">183</td>
</tr>
<tr>
<td class="tg-0pky">Sections of code should not be commented out</td>
<td class="tg-0pky">Programmers should not comment out code as it bloats programs and reduces readability. <br /> Unused code should be deleted and can be retrieved from source control history if required. <br /> See <br />  <br />    MISRA C:2004, 2.4 - Sections of code should not be &quot;commented out&quot;.  <br />    MISRA C++:2008, 2-7-2 - Sections of code shall not be &quot;commented out&quot; using C-style comments.  <br />    MISRA C++:2008, 2-7-3 - Sections of code should not be &quot;commented out&quot; using C++ comments.  <br />    MISRA C:2012, Dir. 4.4 - Sections of code should not be &quot;commented out&quot;  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">10</td>
</tr>
<tr>
<td class="tg-0pky">&quot;for&quot; loop stop conditions should be invariant</td>
<td class="tg-0pky">A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and <br /> ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.  <br /> Stop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the <br /> introduction of errors in the future. <br /> This rule tracks three types of non-invariant stop conditions: <br />  <br />    When the loop counters are updated in the body of the for loop  <br />    When the stop condition depend upon a method call  <br />    When the stop condition depends on an object property, since such properties could change during the execution of the loop.  <br />  <br /> Noncompliant Code Example <br />  <br /> for (int i = 0; i &lt; 10; i++) { <br />   ... <br />   i = i - 1; // Noncompliant; counter updated in the body of the loop <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (int i = 0; i &lt; 10; i++) {...} <br />  <br /> See <br />  <br />    MISRA C:2004, 13.6 - Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the <br />   loop.  <br />    MISRA C++:2008, 6-5-3 - The loop-counter shall not be modified within condition or statement.  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">105</td>
</tr>
<tr>
<td class="tg-0pky">Local variables should not shadow class fields</td>
<td class="tg-0pky">Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of <br /> code. Further, it could lead maintainers to introduce bugs because they think they&#39;re using one variable but are really using another. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   public int myField; <br />  <br />   public void doSomething() { <br />     int myField = 0; <br />     ... <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL01-C. - Do not reuse <br />   variable names in subscopes  <br />    CERT, DCL51-J. - Do <br />   not shadow or obscure identifiers in subscopes  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">7</td>
</tr>
<tr>
<td class="tg-0pky">Labels should not be used</td>
<td class="tg-0pky">Labels are not commonly used in Java, and many developers do not understand how they work. Moreover, their usage makes the control flow harder to <br /> follow, which reduces the code&#39;s readability. <br /> Noncompliant Code Example <br />  <br /> int matrix[][] = { <br />   {1, 2, 3}, <br />   {4, 5, 6}, <br />   {7, 8, 9} <br /> }; <br />  <br /> outer: for (int row = 0; row &lt; matrix.length; row++) {   // Non-Compliant <br />   for (int col = 0; col &lt; matrix[row].length; col++) { <br />     if (col == row) { <br />       continue outer; <br />     } <br />     System.out.println(matrix[row][col]);                // Prints the elements under the diagonal, i.e. 4, 7 and 8 <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> for (int row = 1; row &lt; matrix.length; row++) {          // Compliant <br />   for (int col = 0; col &lt; row; col++) { <br />     System.out.println(matrix[row][col]);                // Also prints 4, 7 and 8 <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Inheritance tree of classes should not be too deep</td>
<td class="tg-0pky">Inheritance is certainly one of the most valuable concepts in object-oriented programming. It&#39;s a way to compartmentalize and reuse code by <br /> creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating <br /> a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object <br /> oriented design which has led to systematically use &#39;inheritance&#39; when for instance &#39;composition&#39; would suit better. <br /> This rule raises an issue when the inheritance tree, starting from Object has a greater depth than is allowed.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">19</td>
</tr>
<tr>
<td class="tg-0pky">Deprecated elements should have both the annotation and the Javadoc tag</td>
<td class="tg-0pky">Deprecation should be marked with both the @Deprecated annotation and @deprecated Javadoc tag. The annotation enables tools such as <br /> IDEs to warn about referencing deprecated elements, and the tag can be used to explain when it was deprecated, why, and how references should be <br /> refactored.  <br /> Further, Java 9 adds two additional arguments to the annotation: <br />  <br />    since allows you to describe when the deprecation took place  <br />    forRemoval, indicates whether the deprecated element will be removed at some future date  <br />  <br /> If your compile level is Java 9 or higher, you should be using one or both of these arguments. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   @Deprecated <br />   public void foo1() { <br />   } <br />  <br />   /<strong> <br />     <em> @deprecated <br />     </em>/ <br />   public void foo2() {    // Noncompliant <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   /</strong> <br />     <em> @deprecated (when, why, refactoring advice...) <br />     </em>/ <br />   @Deprecated <br />   public void foo1() { <br />   } <br />  <br />   /<strong> <br />     <em> Java &gt;= 9 <br />     </em> @deprecated (when, why, refactoring advice...) <br />     */ <br />   @Deprecated(since=&quot;5.1&quot;) <br />   public void foo2() { <br />   } <br />  <br />   /</strong> <br />     <em> Java &gt;= 9 <br />     </em> @deprecated (when, why, refactoring advice...) <br />     <em>/ <br />   @Deprecated(since=&quot;4.2&quot;, forRemoval=true) <br />   public void foo3() { <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> The members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to <br /> it. <br />  <br /> /** <br />  </em> @deprecated (when, why, etc...) <br />  <em>/ <br /> @Deprecated <br /> class Qix  { <br />  <br />   public void foo() {} // Compliant; class is deprecated <br />  <br /> } <br />  <br /> /** <br />  </em> @deprecated (when, why, etc...) <br />  */ <br /> @Deprecated <br /> interface Plop { <br />  <br />   void bar(); <br />  <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Methods should not have too many parameters</td>
<td class="tg-0pky">A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many <br /> things. <br /> Noncompliant Code Example <br /> With a maximum number of 4 parameters: <br />  <br /> public void doSomething(int param1, int param2, int param3, String param4, long param5) { <br /> ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int param1, int param2, int param3, String param4) { <br /> ... <br /> } <br />  <br /> Exceptions <br /> Methods annotated with Spring&#39;s @RequestMapping (and related shortcut annotations, like @GetRequest) or <br /> @JsonCreator may have a lot of parameters, encapsulation being possible. Such methods are therefore ignored.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">61</td>
</tr>
<tr>
<td class="tg-0pky">Generic exceptions should never be thrown</td>
<td class="tg-0pky">Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents <br /> calling methods from handling true, system-generated exceptions differently than application-generated errors.  <br /> Noncompliant Code Example <br />  <br /> public void foo(String bar) throws Throwable {  // Noncompliant <br />   throw new RuntimeException(&quot;My Message&quot;);     // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo(String bar) { <br />   throw new MyOwnRuntimeException(&quot;My Message&quot;); <br /> } <br />  <br /> Exceptions <br /> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration <br /> in the superclass. The issue will be raised on superclass declaration of the method (or won&#39;t be raised at all if superclass is not part of the <br /> analysis). <br />  <br /> @Override <br /> public void myMethod() throws Exception {...} <br />  <br /> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. <br />  <br /> public void myOtherMethod throws Exception { <br />   doTheThing();  // this method throws Exception <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-397 - Declaration of Throws for Generic Exception  <br />    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable <br />    <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">29</td>
</tr>
<tr>
<td class="tg-0pky">Constant names should comply with a naming convention</td>
<td class="tg-0pky">Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[A-Z][A-Z0-9]<em>(_[A-Z0-9]+)</em>$: <br />  <br /> public class MyClass { <br />   public static final int first = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   first; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public static final int FIRST = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   FIRST; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">567</td>
</tr>
<tr>
<td class="tg-0pky">Standard outputs should not be used directly to log anything</td>
<td class="tg-0pky">When logging a message there are several important requirements which must be fulfilled: <br />  <br />    The user must be able to easily retrieve the logs  <br />    The format of all logged message must be uniform to allow the user to easily read the log  <br />    Logged data must actually be recorded  <br />    Sensitive data must only be logged securely  <br />  <br /> If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That&#39;s why defining and using a <br /> dedicated logger is highly recommended. <br /> Noncompliant Code Example <br />  <br /> System.out.println(&quot;My Message&quot;);  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> logger.log(&quot;My Message&quot;); <br />  <br /> See <br />  <br />    CERT, ERR02-J. - Prevent exceptions while logging data  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">18</td>
</tr>
<tr>
<td class="tg-0pky">Collapsible &quot;if&quot; statements should be merged</td>
<td class="tg-0pky">Merging collapsible if statements increases the code&#39;s readability. <br /> Noncompliant Code Example <br />  <br /> if (file != null) { <br />   if (file.isFile() &amp;#124&amp;#124 file.isDirectory()) { <br />     /<em> ... </em>/ <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (file != null &amp;&amp; isFileOrDirectory(file)) { <br />   /<em> ... </em>/ <br /> } <br />  <br /> private static boolean isFileOrDirectory(File file) { <br />   return file.isFile() &amp;#124&amp;#124 file.isDirectory(); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">43</td>
</tr>
<tr>
<td class="tg-0pky">Unused &quot;private&quot; fields should be removed</td>
<td class="tg-0pky">If a private field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will <br /> improve maintainability because developers will not wonder what the variable is used for. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private fields that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private int foo = 42; <br />  <br />   public int compute(int a) { <br />     return a <em> 42; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public int compute(int a) { <br />     return a </em> 42; <br />   } <br /> } <br />  <br /> Exceptions <br /> The Java serialization runtime associates with each serializable class a version number, called serialVersionUID, which is used during <br /> deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to <br /> serialization. <br /> A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that <br /> must be static, final, and of type long. By definition those serialVersionUID fields should not be reported by this rule: <br />  <br /> public class MyClass implements java.io.Serializable { <br />   private static final long serialVersionUID = 42L; <br /> } <br />  <br /> Moreover, this rule doesn&#39;t raise any issue on annotated fields.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">11</td>
</tr>
<tr>
<td class="tg-0pky">Utility classes should not have public constructors</td>
<td class="tg-0pky">Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can <br /> be extended, should not have public constructors. <br /> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor <br /> should be defined. <br /> Noncompliant Code Example <br />  <br /> class StringUtils { // Noncompliant <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class StringUtils { // Compliant <br />  <br />   private StringUtils() { <br />     throw new IllegalStateException(&quot;Utility class&quot;); <br />   } <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this <br /> rule.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">5</td>
</tr>
<tr>
<td class="tg-0pky">Track uses of &quot;FIXME&quot; tags</td>
<td class="tg-0pky">FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> Noncompliant Code Example <br />  <br /> int divide(int numerator, int denominator) { <br />   return numerator / denominator;              // FIXME denominator value might be  0 <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">19</td>
</tr>
<tr>
<td class="tg-0pky">Try-catch blocks should not be nested</td>
<td class="tg-0pky">Nesting try/catch blocks severely impacts the readability of source code because it makes it too difficult to understand <br /> which block will catch which exception.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">79</td>
</tr>
<tr>
<td class="tg-0pky">Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used</td>
<td class="tg-0pky">Early classes of the Java API, such as Vector, Hashtable and StringBuffer, were synchronized to make them <br /> thread-safe. Unfortunately, synchronization has a big negative impact on performance, even when using these collections from a single thread. <br /> It is better to use their new unsynchronized replacements: <br />  <br />    ArrayList or LinkedList instead of Vector  <br />    Deque instead of Stack  <br />    HashMap instead of Hashtable  <br />    StringBuilder instead of StringBuffer  <br />  <br /> Noncompliant Code Example <br />  <br /> Vector cats = new Vector(); <br />  <br /> Compliant Solution <br />  <br /> ArrayList cats = new ArrayList(); <br />  <br /> Exceptions <br /> Use of those synchronized classes is ignored in the signatures of overriding methods. <br />  <br /> @Override <br /> public Vector getCats() {...} <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Empty arrays and collections should be returned instead of null</td>
<td class="tg-0pky">Returning null instead of an actual array or collection forces callers of the method to explicitly test for nullity, making them more <br /> complex and less readable. <br /> Moreover, in many cases, null is used as a synonym for empty. <br /> Noncompliant Code Example <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static void main(String[] args) { <br />   Result[] results = getResults(); <br />  <br />   if (results != null) {                   // Nullity test required to prevent NPE <br />     for (Result result: results) { <br />       /<em> ... </em>/ <br />     } <br />   } <br /> } <br />  <br />  <br /> Compliant Solution <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return Collections.emptyList();          // Compliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return new Result[0]; <br /> } <br />  <br /> public static void main(String[] args) { <br />   for (Result result: getResults()) { <br />     /<em> ... </em>/ <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC19-C. - For functions that return an array, prefer returning an <br />   empty array over a null value  <br />    CERT, MET55-J. - Return an empty array or collection instead of a null <br />   value for methods that return an array or collection  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">27</td>
</tr>
<tr>
<td class="tg-0pky">Only static class initializers should be used</td>
<td class="tg-0pky">Non-static initializers are rarely used, and can be confusing for most developers because they only run when new class instances are created. When <br /> possible, non-static initializers should be refactored into standard constructors or field initializers. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />   private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;() { <br />  <br />     // Noncompliant - HashMap should be extended only to add behavior, not for initialization <br />     { <br />       put(&quot;a&quot;, &quot;b&quot;); <br />     } <br />  <br />   }; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />   private static final Map&lt;String, String&gt; MY_MAP = new HashMap&lt;String, String&gt;(); <br />  <br />   static { <br />     MY_MAP.put(&quot;a&quot;, &quot;b&quot;); <br />   } <br /> } <br />  <br /> or using Guava: <br />  <br /> class MyClass { <br />   // Compliant <br />   private static final Map&lt;String, String&gt; MY_MAP = ImmutableMap.of(&quot;a&quot;, &quot;b&quot;); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Unused method parameters should be removed</td>
<td class="tg-0pky">Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same. <br /> Noncompliant Code Example <br />  <br /> void doSomething(int a, int b) {     // &quot;b&quot; is unused <br />   compute(a); <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething(int a) { <br />   compute(a); <br /> } <br />  <br /> Exceptions <br /> The rule will not raise issues for unused parameters: <br />  <br />    that are annotated with @javax.enterprise.event.Observes  <br />    in overrides and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw or that have empty bodies  <br />    in annotated methods, unless the annotation is @SuppressWarning(&quot;unchecked&quot;) or @SuppressWarning(&quot;rawtypes&quot;), in <br />   which case the annotation will be ignored  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper <br />   javadoc.  <br />  <br />  <br /> @Override <br /> void doSomething(int a, int b) {     // no issue reported on b <br />   compute(a); <br /> } <br />  <br /> public void foo(String s) { <br />   // designed to be extended but noop in standard case <br /> } <br />  <br /> protected void bar(String s) { <br />   //open-closed principle <br /> } <br />  <br /> public void qix(String s) { <br />   throw new UnsupportedOperationException(&quot;This method should be implemented in subclasses&quot;); <br /> } <br />  <br /> /<em>* <br />  </em> @param s This string may be use for further computation in overriding classes <br />  */ <br /> protected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc <br />   compute(a); <br /> } <br />  <br /> See <br />  <br />    MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions.  <br />    MISRA C:2012, 2.7 - There should be no unused parameters in functions  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">46</td>
</tr>
<tr>
<td class="tg-0pky">Throwable and Error should not be caught</td>
<td class="tg-0pky">Throwable is the superclass of all errors and exceptions in Java. Error is the superclass of all errors, which are not <br /> meant to be caught by applications. <br /> Catching either Throwable or Error will also catch OutOfMemoryError and InternalError, from <br /> which an application should not attempt to recover. <br /> Noncompliant Code Example <br />  <br /> try { /<em> ... </em>/ } catch (Throwable t) { /<em> ... </em>/ } <br /> try { /<em> ... </em>/ } catch (Error e) { /<em> ... </em>/ } <br />  <br /> Compliant Solution <br />  <br /> try { /<em> ... </em>/ } catch (RuntimeException e) { /<em> ... </em>/ } <br /> try { /<em> ... </em>/ } catch (MyException e) { /<em> ... </em>/ } <br />  <br /> See <br />  <br />    MITRE, CWE-396 - Declaration of Catch for Generic Exception  <br />    CERT, ERR08-J. - Do not catch NullPointerException or any of its ancestors <br />    <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">29</td>
</tr>
<tr>
<td class="tg-0pky">Classes from &quot;sun.*&quot; packages should not be used</td>
<td class="tg-0pky">Classes in the sun.<em> or com.sun.</em> packages are considered implementation details, and are not part of the Java API. <br /> They can cause problems when moving to new versions of Java because there is no backwards compatibility guarantee. Similarly, they can cause <br /> problems when moving to a different Java vendor, such as OpenJDK. <br /> Such classes are almost always wrapped by Java API classes that should be used instead. <br /> Noncompliant Code Example <br />  <br /> import com.sun.jna.Native;     // Noncompliant <br /> import sun.misc.BASE64Encoder; // Noncompliant <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">String literals should not be duplicated</td>
<td class="tg-0pky">Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. <br /> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. <br /> Noncompliant Code Example <br /> With the default threshold of 3: <br />  <br /> public void run() { <br />   prepare(&quot;action1&quot;);                              // Noncompliant - &quot;action1&quot; is duplicated 3 times <br />   execute(&quot;action1&quot;); <br />   release(&quot;action1&quot;); <br /> } <br />  <br /> @SuppressWarning(&quot;all&quot;)                            // Compliant - annotations are excluded <br /> private void method1() { /<em> ... </em>/ } <br /> @SuppressWarning(&quot;all&quot;) <br /> private void method2() { /<em> ... </em>/ } <br />  <br /> public String method3(String a) { <br />   System.out.println(&quot;&#39;&quot; + a + &quot;&#39;&quot;);               // Compliant - literal &quot;&#39;&quot; has less than 5 characters and is excluded <br />   return &quot;&quot;;                                       // Compliant - literal &quot;&quot; has less than 5 characters and is excluded <br /> } <br />  <br /> Compliant Solution <br />  <br /> private static final String ACTION_1 = &quot;action1&quot;;  // Compliant <br />  <br /> public void run() { <br />   prepare(ACTION_1);                               // Compliant <br />   execute(ACTION_1); <br />   release(ACTION_1); <br /> } <br />  <br /> Exceptions <br /> To prevent generating some false-positives, literals having less than 5 characters are excluded.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">236</td>
</tr>
<tr>
<td class="tg-0pky">Exception types should not be tested using &quot;instanceof&quot; in catch blocks</td>
<td class="tg-0pky">Multiple catch blocks of the appropriate type should be used instead of catching a general exception, and then testing on the type. <br /> Noncompliant Code Example <br />  <br /> try { <br />   /<em> ... </em>/ <br /> } catch (Exception e) { <br />   if(e instanceof IOException) { /<em> ... </em>/ }         // Noncompliant <br />   if(e instanceof NullPointerException{ /<em> ... </em>/ }  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> try { <br />   /<em> ... </em>/ <br /> } catch (IOException e) { /<em> ... </em>/ }                // Compliant <br /> } catch (NullPointerException e) { /<em> ... </em>/ }       // Compliant <br />  <br /> See <br />  <br />    CERT, ERR51-J. - Prefer user-defined exceptions over more general exception <br />   types  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;switch&quot; statements should not have too many &quot;case&quot; clauses</td>
<td class="tg-0pky">When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A real map <br /> structure would be more readable and maintainable, and should be used instead. <br /> Exceptions <br /> This rule ignores switches over Enums and empty, fall-through cases.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">A field should not duplicate the name of its containing class</td>
<td class="tg-0pky">It&#39;s confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider <br /> the common practice of naming a class instance for the class itself. <br /> Best practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular <br /> aspect of the class it represents or holds. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   private String foo; <br />  <br />   public String getFoo() { } <br /> } <br />  <br /> Foo foo = new Foo(); <br /> foo.getFoo() // what does this return? <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />   private String name; <br />  <br />   public String getName() { } <br /> } <br />  <br /> //... <br />  <br /> Foo foo = new Foo(); <br /> foo.getName() <br />  <br />  <br /> Exceptions <br /> When the type of the field is the containing class and that field is static, no issue is raised to allow singletons named like the type.  <br />  <br /> public class Foo { <br />   ... <br />   private static Foo foo; <br />   public Foo getInstance() { <br />     if(foo==null) { <br />       foo = new Foo(); <br />     } <br />     return foo; <br />   } <br />   ... <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">9</td>
</tr>
<tr>
<td class="tg-0pky">Methods and field names should not be the same or differ only by capitalization</td>
<td class="tg-0pky">Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is <br /> confusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field <br /> with exactly the same name and visibility. <br /> In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead <br /> added a new method with nearly the same name. <br /> Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the <br /> case where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be <br /> disruptive to callers. Therefore renaming the member is the recommended action. <br /> Noncompliant Code Example <br />  <br /> public class Car{ <br />  <br />   public DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // Noncompliant; duplicates field name <br /> } <br />  <br /> public class MyCar extends Car{ <br />   public void teardown(){...}  // Noncompliant; not an override. It it really what&#39;s intended? <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveFast(){...} //Huh? <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Car{ <br />  <br />   private DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // field visibility reduced <br /> } <br />  <br /> public class MyCar extends Car{ <br />   @Override <br />   public void tearDown(){...} <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveReallyFast(){...} <br />  <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">10</td>
</tr>
<tr>
<td class="tg-0pky">Dead stores should be removed</td>
<td class="tg-0pky">A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value <br /> only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it&#39;s not an error, it is at best a waste of resources. <br /> Therefore all calculated values should be used. <br /> Noncompliant Code Example <br />  <br /> i = a + b; // Noncompliant; calculation result not used before value is overwritten <br /> i = compute(); <br />  <br /> Compliant Solution <br />  <br /> i = a + b; <br /> i += compute(); <br />  <br /> Exceptions <br /> This rule ignores initializations to -1, 0, 1, null, true, false and &quot;&quot;. <br /> See <br />  <br />    MITRE, CWE-563 - Assignment to Variable without Use (&#39;Unused Variable&#39;)  <br />    CERT, MSC13-C. - Detect and remove unused values  <br />    CERT, MSC56-J. - Detect and remove superfluous code and values  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">41</td>
</tr>
<tr>
<td class="tg-0pky">Two branches in a conditional structure should not have exactly the same implementation</td>
<td class="tg-0pky">Having two cases in a switch statement or two branches in an if chain with the same implementation is at <br /> best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if chain they should <br /> be combined, or for a switch, one should fall through to the other.  <br /> Noncompliant Code Example <br />  <br /> switch (i) { <br />   case 1: <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   case 2: <br />     doSomethingDifferent(); <br />     break; <br />   case 3:  // Noncompliant; duplicates case 1&#39;s implementation <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   default: <br />     doTheRest(); <br /> } <br />  <br /> if (a &gt;= 0 &amp;&amp; a &lt; 10) { <br />   doFirstThing(); <br />   doTheThing(); <br /> } <br /> else if (a &gt;= 10 &amp;&amp; a &lt; 20) { <br />   doTheOtherThing(); <br /> } <br /> else if (a &gt;= 20 &amp;&amp; a &lt; 50) { <br />   doFirstThing(); <br />   doTheThing();  // Noncompliant; duplicates first condition <br /> } <br /> else { <br />   doTheRest(); <br /> } <br />  <br /> Exceptions <br /> Blocks in an if chain that contain a single line of code are ignored, as are blocks in a switch statement that contain a <br /> single line of code with or without a following break. <br />  <br /> if(a == 1) { <br />   doSomething();  //no issue, usually this is done on purpose to increase the readability <br /> } else if (a == 2) { <br />   doSomethingElse(); <br /> } else { <br />   doSomething(); <br /> } <br />  <br /> But this exception does not apply to if chains without else-s, or to switch-es without default clauses when <br /> all branches have the same single line of code. In case of if chains with else-s, or of switch-es with default <br /> clauses, rule S3923 raises a bug.  <br />  <br /> if(a == 1) { <br />   doSomething();  //Noncompliant, this might have been done on purpose but probably not <br /> } else if (a == 2) { <br />   doSomething(); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">7</td>
</tr>
<tr>
<td class="tg-0pky">Constructors should not be used to instantiate &quot;String&quot;, &quot;BigInteger&quot;, &quot;BigDecimal&quot; and primitive-wrapper classes</td>
<td class="tg-0pky">Constructors for String, BigInteger, BigDecimal and the objects used to wrap primitives should never be <br /> used. Doing so is less clear and uses more memory than simply using the desired value in the case of strings, and using valueOf for <br /> everything else. <br /> Noncompliant Code Example <br />  <br /> String empty = new String(); // Noncompliant; yields essentially &quot;&quot;, so just use that. <br /> String nonempty = new String(&quot;Hello world&quot;); // Noncompliant <br /> Double myDouble = new Double(1.1); // Noncompliant; use valueOf <br /> Integer integer = new Integer(1); // Noncompliant <br /> Boolean bool = new Boolean(true); // Noncompliant <br /> BigInteger bigInteger1 = new BigInteger(&quot;3&quot;); // Noncompliant <br /> BigInteger bigInteger2 = new BigInteger(&quot;9223372036854775807&quot;); // Noncompliant <br /> BigInteger bigInteger3 = new BigInteger(&quot;111222333444555666777888999&quot;); // Compliant, greater than Long.MAX_VALUE <br />  <br /> Compliant Solution <br />  <br /> String empty = &quot;&quot;; <br /> String nonempty = &quot;Hello world&quot;; <br /> Double myDouble = Double.valueOf(1.1); <br /> Integer integer = Integer.valueOf(1); <br /> Boolean bool = Boolean.valueOf(true); <br /> BigInteger bigInteger1 = BigInteger.valueOf(3); <br /> BigInteger bigInteger2 = BigInteger.valueOf(9223372036854775807L); <br /> BigInteger bigInteger3 = new BigInteger(&quot;111222333444555666777888999&quot;); <br />  <br /> Exceptions <br /> BigDecimal constructor with double argument is ignored as using valueOf instead might change resulting <br /> value. See S2111.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">12</td>
</tr>
<tr>
<td class="tg-0pky">&quot;static&quot; members should be accessed statically</td>
<td class="tg-0pky">While it is possible to access static members from a class instance, it&#39;s bad form, and considered by most to be misleading <br /> because it implies to the readers of your code that there&#39;s an instance of the member per class instance. <br /> Noncompliant Code Example <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     first.counter ++;  // Noncompliant <br />     second.counter ++;  // Noncompliant. A.counter is now 2, which is perhaps contrary to expectations <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     A.counter ++;  // Compliant <br />     A.counter ++;  // Compliant <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;Threads&quot; should not be used where &quot;Runnables&quot; are expected</td>
<td class="tg-0pky">While it is technically correct to use a Thread where a Runnable is called for, the semantics of the two objects are <br /> different, and mixing them is a bad practice that will likely lead to headaches in the future. <br /> The crux of the issue is that Thread is a larger concept than Runnable. A Runnable is an object whose <br /> running should be managed. A Thread expects to manage the running of itself or other Runnables.  <br /> Noncompliant Code Example <br />  <br />     public static void main(String[] args) { <br />         Thread r =new Thread() { <br />             int p; <br />             @Override <br />             public void run() { <br />                 while(true) <br />                     System.out.println(&quot;a&quot;); <br />             } <br />         }; <br />         new Thread(r).start();  // Noncompliant <br />  <br /> Compliant Solution <br />  <br />     public static void main(String[] args) { <br />         Runnable r =new Runnable() { <br />             int p; <br />             @Override <br />             public void run() { <br />                 while(true) <br />                     System.out.println(&quot;a&quot;); <br />             } <br />         }; <br />         new Thread(r).start(); <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">11</td>
</tr>
<tr>
<td class="tg-0pky">&quot;Lock&quot; objects should not be &quot;synchronized&quot;</td>
<td class="tg-0pky">java.util.concurrent.locks.Lock offers far more powerful and flexible locking operations than are available with <br /> synchronized blocks. So synchronizing on a Lock throws away the power of the object, and is just silly. Instead, such <br /> objects should be locked and unlocked using tryLock() and unlock(). <br /> Noncompliant Code Example <br />  <br /> Lock lock = new MyLockImpl(); <br /> synchronized(lock) {  // Noncompliant <br />   //... <br /> } <br />  <br /> Compliant Solution <br />  <br /> Lock lock = new MyLockImpl(); <br /> lock.tryLock(); <br /> //... <br />  <br /> See <br />  <br />    CERT, LCK03-J. - Do not synchronize on the intrinsic locks of high-level <br />   concurrency objects  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Boolean expressions should not be gratuitous</td>
<td class="tg-0pky">If a boolean expression doesn&#39;t change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous <br /> because it does not match the programmer&#39;s intent, then it&#39;s a bug and the expression should be fixed. <br /> Noncompliant Code Example <br />  <br /> a = true; <br /> if (a) { // Noncompliant <br />   doSomething(); <br /> } <br />  <br /> if (b &amp;&amp; a) { // Noncompliant; &quot;a&quot; is always &quot;true&quot; <br />   doSomething(); <br /> } <br />  <br /> if (c &amp;#124&amp;#124 !a) { // Noncompliant; &quot;!a&quot; is always &quot;false&quot; <br />   doSomething(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> a = true; <br /> if (foo(a)) { <br />   doSomething(); <br /> } <br />  <br /> if (b) { <br />   doSomething(); <br /> } <br />  <br /> if (c) { <br />   doSomething(); <br /> } <br />  <br /> See <br />  <br />    MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted.  <br />    MISRA C:2012, 14.3 - Controlling expressions shall not be invariant  <br />    MITRE, CWE-571 - Expression is Always True  <br />    MITRE, CWE-570 - Expression is Always False  <br />    MITRE, CWE-489 - Leftover Debug Code  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">31</td>
</tr>
<tr>
<td class="tg-0pky">&quot;Preconditions&quot; and logging arguments should not require evaluation</td>
<td class="tg-0pky">Passing message arguments that require further evaluation into a Guava com.google.common.base.Preconditions check can result in a <br /> performance penalty. That&#39;s because whether or not they&#39;re needed, each argument must be resolved before the method is actually called. <br /> Similarly, passing concatenated strings into a logging method can also incur a needless performance hit because the concatenation will be performed <br /> every time the method is called, whether or not the log level is low enough to show the message. <br /> Instead, you should structure your code to pass static or pre-computed values into Preconditions conditions check and logging <br /> calls. <br /> Specifically, the built-in string formatting should be used instead of string concatenation, and if the message is the result of a method call, <br /> then Preconditions should be skipped altoghether, and the relevant exception should be conditionally thrown instead. <br /> Noncompliant Code Example <br />  <br /> logger.log(Level.DEBUG, &quot;Something went wrong: &quot; + message);  // Noncompliant; string concatenation performed even when log level too high to show DEBUG messages <br />  <br /> logger.fine(&quot;An exception occurred with message: &quot; + message); // Noncompliant <br />  <br /> LOG.error(&quot;Unable to open file &quot; + csvPath, e);  // Noncompliant <br />  <br /> Preconditions.checkState(a &gt; 0, &quot;Arg must be positive, but got &quot; + a);  // Noncompliant. String concatenation performed even when a &gt; 0 <br />  <br /> Preconditions.checkState(condition, formatMessage());  // Noncompliant. formatMessage() invoked regardless of condition <br />  <br /> Preconditions.checkState(condition, &quot;message: %s&quot;, formatMessage());  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> logger.log(Level.SEVERE, &quot;Something went wrong: {0} &quot;, message);  // String formatting only applied if needed <br />  <br /> logger.fine(&quot;An exception occurred with message: {}&quot;, message);  // SLF4J, Log4j <br />  <br /> logger.log(Level.SEVERE, () -&gt; &quot;Something went wrong: &quot; + message); // since Java 8, we can use Supplier , which will be evaluated lazily <br />  <br /> LOG.error(&quot;Unable to open file {0}&quot;, csvPath, e); <br />  <br /> if (LOG.isDebugEnabled() { <br />   LOG.debug(&quot;Unable to open file &quot; + csvPath, e);  // this is compliant, because it will not evaluate if log level is above debug. <br /> } <br />  <br /> Preconditions.checkState(arg &gt; 0, &quot;Arg must be positive, but got %d&quot;, a);  // String formatting only applied if needed <br />  <br /> if (!condition) { <br />   throw new IllegalStateException(formatMessage());  // formatMessage() only invoked conditionally <br /> } <br />  <br /> if (!condition) { <br />   throw new IllegalStateException(&quot;message: &quot; + formatMessage()); <br /> } <br />  <br /> Exceptions <br /> catch blocks are ignored, because the performance penalty is unimportant on exceptional paths (catch block should not be a part of <br /> standard program flow). Getters are ignored as well as methods called on annotations which can be considered as getters. This rule accounts for <br /> explicit test-level testing with SLF4J methods isXXXEnabled and ignores the bodies of such if statements.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">5</td>
</tr>
<tr>
<td class="tg-0pky">&quot;clone&quot; should not be overridden</td>
<td class="tg-0pky">Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky <br /> and difficult to get right, according to Joshua Bloch: <br />  <br />   Object&#39;s clone method is very tricky. It&#39;s based on field copies, and it&#39;s &quot;extra-linguistic.&quot; It creates an object without calling a constructor. <br />   There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and <br />   outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow <br />   copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don&#39;t have two independent objects. <br />   If you modify one, the other changes as well. And all of a sudden, you get random behavior. <br />  <br /> A copy constructor or copy factory should be used instead. <br /> This rule raises an issue when clone is overridden, whether or not Cloneable is implemented. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   // ... <br />  <br />   public Object clone() { // Noncompliant <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   // ... <br />  <br />   MyClass (MyClass source) { <br />     //... <br />   } <br /> } <br />  <br /> See <br />  <br />    Copy Constructor versus Cloning  <br />  <br /> See Also <br />  <br />    S2157 - &quot;Cloneables&quot; should implement &quot;clone&quot;  <br />    S1182 - Classes that override &quot;clone&quot; should be &quot;Cloneable&quot; and call &quot;super.clone()&quot;  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">15</td>
</tr>
<tr>
<td class="tg-0pky">Static fields should not be updated in constructors</td>
<td class="tg-0pky">Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all <br /> instances of the class. <br /> Instead remove the field&#39;s static modifier, or initialize it statically. <br /> Noncompliant Code Example <br />  <br /> public class Person { <br />   static Date dateOfBirth; <br />   static int expectedFingers; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday <br />     expectedFingers = 10;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Person { <br />   Date dateOfBirth; <br />   static int expectedFingers = 10; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday; <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">18</td>
</tr>
<tr>
<td class="tg-0pky">Ternary operators should not be nested</td>
<td class="tg-0pky">Just because you can do something, doesn&#39;t mean you should, and that&#39;s the case with nested ternary operations. Nesting ternary operators <br /> results in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you) <br /> scratching their heads and cursing. <br /> Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement. <br /> Noncompliant Code Example <br />  <br /> public String getTitle(Person p) { <br />   return p.gender == Person.MALE ? &quot;Mr. &quot; : p.isMarried() ? &quot;Mrs. &quot; : &quot;Miss &quot;;  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public String getTitle(Person p) { <br />   if (p.gender == Person.MALE) { <br />     return &quot;Mr. &quot;; <br />   } <br />   return p.isMarried() ? &quot;Mrs. &quot; : &quot;Miss &quot;; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">8</td>
</tr>
<tr>
<td class="tg-0pky">Methods should not have identical implementations</td>
<td class="tg-0pky">When two methods have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but may <br /> be confusing to maintainers. In the latter case, one implementation should invoke the other. Numerical and string literals are not taken into account. <br />  <br /> Noncompliant Code Example <br />  <br /> private final static String CODE = &quot;bounteous&quot;; <br />  <br /> public String calculateCode() { <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> public String getName() {  // Noncompliant <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> Compliant Solution <br />  <br /> private final static String CODE = &quot;bounteous&quot;; <br />  <br /> public String getCode() { <br />   doTheThing(); <br />   return CODE; <br /> } <br />  <br /> public String getName() { <br />   return getCode(); <br /> } <br />  <br /> Exceptions <br /> Methods that are not accessors (getters and setters), with fewer than 2 statements are ignored.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Assignments should not be redundant</td>
<td class="tg-0pky">The transitive property says that if a == b and b == c, then a == c. In such cases, there&#39;s no point in <br /> assigning a to c or vice versa because they&#39;re already equivalent.  <br /> This rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths. <br /> Noncompliant Code Example <br />  <br /> a = b; <br /> c = a; <br /> b = c; // Noncompliant: c and b are already the same <br />  <br /> Compliant Solution <br />  <br /> a = b; <br /> c = a; <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Unused &quot;private&quot; methods should be removed</td>
<td class="tg-0pky">private methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code <br /> decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private methods that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class Foo implements Serializable <br /> { <br />   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. <br />   public static void doSomething(){ <br />     Foo foo = new Foo(); <br />     ... <br />   } <br />   private void unusedPrivateMethod(){...} <br />   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism <br />   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo implements Serializable <br /> { <br />   private Foo(){}     //Compliant, private empty constructor intentionally used to prevent any direct instantiation of a class. <br />   public static void doSomething(){ <br />     Foo foo = new Foo(); <br />     ... <br />   } <br />  <br />   private void writeObject(ObjectOutputStream s){...}  //Compliant, relates to the java serialization mechanism <br />  <br />   private void readObject(ObjectInputStream in){...}  //Compliant, relates to the java serialization mechanism <br /> } <br />  <br /> Exceptions <br /> This rule doesn&#39;t raise any issue on annotated methods.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MAJOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">&quot;@Deprecated&quot; code should not be used</td>
<td class="tg-0pky">Once deprecated, classes, and interfaces, and their members should be avoided, rather than used, inherited or extended. Deprecation is a warning <br /> that the class or interface has been superseded, and will eventually be removed. The deprecation period allows you to make a smooth transition away <br /> from the aging, soon-to-be-retired technology. <br /> Noncompliant Code Example <br />  <br /> /<strong> <br />  <em> @deprecated  As of release 1.3, replaced by {@link #Fee} <br />  </em>/ <br /> @Deprecated <br /> public class Fum { ... } <br />  <br /> public class Foo { <br />   /</strong> <br />    <em> @deprecated  As of release 1.7, replaced by {@link #doTheThingBetter()} <br />    </em>/ <br />   @Deprecated <br />   public void doTheThing() { ... } <br />  <br />   public void doTheThingBetter() { ... } <br /> } <br />  <br /> public class Bar extends Foo { <br />   public void doTheThing() { ... } // Noncompliant; don&#39;t override a deprecated method or explicitly mark it as @Deprecated <br /> } <br />  <br /> public class Bar extends Fum {  // Noncompliant; Fum is deprecated <br />  <br />   public void myMethod() { <br />     Foo foo = new Foo();  // okay; the class isn&#39;t deprecated <br />     foo.doTheThing();  // Noncompliant; doTheThing method is deprecated <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-477 - Use of Obsolete Functions  <br />    CERT, MET02-J. - Do not use deprecated or obsolete classes or methods  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">169</td>
</tr>
<tr>
<td class="tg-0pky">Modifiers should be declared in the correct order</td>
<td class="tg-0pky">The Java Language Specification recommends listing modifiers in the following order: <br /> 1. Annotations <br /> 2. public <br /> 3. protected <br /> 4. private <br /> 5. abstract <br /> 6. static <br /> 7. final <br /> 8. transient <br /> 9. volatile <br /> 10. synchronized <br /> 11. native <br /> 12. strictfp <br /> Not following this convention has no technical impact, but will reduce the code&#39;s readability because most developers are used to the standard <br /> order. <br /> Noncompliant Code Example <br />  <br /> static public void main(String[] args) {   // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public static void main(String[] args) {   // Compliant <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">13</td>
</tr>
<tr>
<td class="tg-0pky">&quot;throws&quot; declarations should not be superfluous</td>
<td class="tg-0pky">An exception in a throws declaration in Java is superfluous if it is: <br />  <br />    listed multiple times  <br />    a subclass of another listed exception  <br />    a RuntimeException, or one of its descendants  <br />    completely unnecessary because the declared exception type cannot actually be thrown  <br />  <br /> Noncompliant Code Example <br />  <br /> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once <br /> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable <br /> void baz() throws RuntimeException {}  // Noncompliant; RuntimeException can always be thrown <br />  <br /> Compliant Solution <br />  <br /> void foo() throws MyException {} <br /> void bar() throws Throwable {} <br /> void baz() {} <br />  <br /> Exceptions <br /> The rule will not raise any issue for exceptions that cannot be thrown from the method body: <br />  <br />    in overriding and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw, have empty bodies, or a single return statement .  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper <br />   javadoc.  <br />  <br />  <br /> class A extends B { <br />   @Override <br />   void doSomething() throws IOException { <br />     compute(a); <br />   } <br />  <br />   public void foo() throws IOException {} <br />  <br />   protected void bar() throws IOException { <br />     throw new UnsupportedOperationException(&quot;This method should be implemented in subclasses&quot;); <br />   } <br />  <br />   Object foobar(String s) throws IOException { <br />     return null; <br />   } <br />  <br />   /<em>* <br />    </em> @throws IOException Overriding classes may throw this exception if they print values into a file <br />    */ <br />   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc <br />     System.out.println(&quot;foo&quot;); <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">73</td>
</tr>
<tr>
<td class="tg-0pky">Method names should comply with a naming convention</td>
<td class="tg-0pky">Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided regular expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public int DoSomething(){...} <br />  <br /> Compliant Solution <br />  <br /> public int doSomething(){...} <br />  <br /> Exceptions <br /> Overriding methods are excluded.  <br />  <br /> @Override <br /> public int Do_Something(){...} <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">55</td>
</tr>
<tr>
<td class="tg-0pky">Class names should comply with a naming convention</td>
<td class="tg-0pky">Shared coding conventions allow teams to collaborate effectively. This rule allows to check that all class names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[A-Z][a-zA-Z0-9]*$: <br />  <br /> class my_class {...} <br />  <br /> Compliant Solution <br />  <br /> class MyClass {...} <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">48</td>
</tr>
<tr>
<td class="tg-0pky">Field names should comply with a naming convention</td>
<td class="tg-0pky">Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field <br /> names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> class MyClass { <br />    private int my_field; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private int myField; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">25</td>
</tr>
<tr>
<td class="tg-0pky">Local variable and method parameter names should comply with a naming convention</td>
<td class="tg-0pky">Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does <br /> not match the provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public void doSomething(int my_param) { <br />   int LOCAL; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int myParam) { <br />   int local; <br />   ... <br /> } <br />  <br /> Exceptions <br /> Loop counters are ignored by this rule. <br />  <br /> for (int i_1 = 0; i_1 &lt; limit; i_1++) {  // Compliant <br />   // ... <br /> } <br />  <br /> as well as one-character catch variables:  <br />  <br /> try { <br /> //... <br /> } catch (Exception e) { // Compliant <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">104</td>
</tr>
<tr>
<td class="tg-0pky">Package names should comply with a naming convention</td>
<td class="tg-0pky">Shared coding conventions allow teams to collaborate efficiently. This rule checks that all package names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z<em>]+(.[a-z</em>][a-z0-9_]<em>)</em>$: <br />  <br /> package org.exAmple; // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> package org.example; <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">URIs should not be hardcoded</td>
<td class="tg-0pky">Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may <br /> not exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems <br /> usually differ from the development environment, ...etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by <br /> customizable parameter. <br /> Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded. <br /> This rule raises an issue when URI&#39;s or path delimiters are hard coded. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   public Collection&lt;User&gt; listUsers() { <br />     File userList = new File(&quot;/home/mylogin/Dev/users.txt&quot;); // Non-Compliant <br />     Collection&lt;User&gt; users = parse(userList); <br />     return users; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />   // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests. <br />   private Configuration config; <br />   public Foo(Configuration myConfig) { <br />     this.config = myConfig; <br />   } <br />   public Collection&lt;User&gt; listUsers() { <br />     // Find here the way to get the correct folder, in this case using the Configuration object <br />     String listingFolder = config.getProperty(&quot;myApplication.listingFolder&quot;); <br />     // and use this parameter instead of the hard coded path <br />     File userList = new File(listingFolder, &quot;users.txt&quot;); // Compliant <br />     Collection&lt;User&gt; users = parse(userList); <br />     return users; <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC03-J. - Never hard code sensitive information  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Boolean literals should not be redundant</td>
<td class="tg-0pky">Redundant Boolean literals should be removed from expressions to improve readability. <br /> Noncompliant Code Example <br />  <br /> if (booleanMethod() == true) { /<em> ... </em>/ } <br /> if (booleanMethod() == false) { /<em> ... </em>/ } <br /> if (booleanMethod() &amp;#124&amp;#124 false) { /<em> ... </em>/ } <br /> doSomething(!false); <br /> doSomething(booleanMethod() == true); <br />  <br /> booleanVariable = booleanMethod() ? true : false; <br /> booleanVariable = booleanMethod() ? true : exp; <br /> booleanVariable = booleanMethod() ? false : exp; <br /> booleanVariable = booleanMethod() ? exp : true; <br /> booleanVariable = booleanMethod() ? exp : false; <br />  <br /> Compliant Solution <br />  <br /> if (booleanMethod()) { /<em> ... </em>/ } <br /> if (!booleanMethod()) { /<em> ... </em>/ } <br /> if (booleanMethod()) { /<em> ... </em>/ } <br /> doSomething(true); <br /> doSomething(booleanMethod()); <br />  <br /> booleanVariable = booleanMethod(); <br /> booleanVariable = booleanMethod() &amp;#124&amp;#124 exp; <br /> booleanVariable = !booleanMethod() &amp;&amp; exp; <br /> booleanVariable = !booleanMethod() &amp;#124&amp;#124 exp; <br /> booleanVariable = booleanMethod() &amp;&amp; exp; <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Return of boolean expressions should not be wrapped into an &quot;if-then-else&quot; statement</td>
<td class="tg-0pky">Return of boolean literal statements wrapped into if-then-else ones should be simplified. <br /> Similarly, method invocations wrapped into if-then-else differing only from boolean literals should be simplified into a single <br /> invocation. <br /> Noncompliant Code Example <br />  <br /> boolean foo(Object param) { <br />   if (expression) { // Noncompliant <br />     bar(param, true, &quot;qix&quot;); <br />   } else { <br />     bar(param, false, &quot;qix&quot;); <br />   } <br />  <br />   if (expression) {  // Noncompliant <br />     return true; <br />   } else { <br />     return false; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> boolean foo(Object param) { <br />   bar(param, expression, &quot;qix&quot;); <br />  <br />   return expression; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Public constants and fields initialized at declaration should be &quot;static final&quot; rather than merely &quot;final&quot;</td>
<td class="tg-0pky">Making a public constant just final as opposed to static final leads to duplicating its value for every <br /> instance of the class, uselessly increasing the amount of memory required to execute the application. <br /> Further, when a non-public, final field isn&#39;t also static, it implies that different instances can have <br /> different values. However, initializing a non-static final field in its declaration forces every instance to have the same value. So such <br /> fields should either be made static or initialized in the constructor. <br /> Noncompliant Code Example <br />  <br /> public class Myclass { <br />   public final int THRESHOLD = 3; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Myclass { <br />   public static final int THRESHOLD = 3;    // Compliant <br /> } <br />  <br /> Exceptions <br /> No issues are reported on final fields of inner classes whose type is not a primitive or a String. Indeed according to the Java specification: <br />  <br />   An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers (§8.7) <br />   or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields (§15.28). <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">9</td>
</tr>
<tr>
<td class="tg-0pky">Classes that override &quot;clone&quot; should be &quot;Cloneable&quot; and call &quot;super.clone()&quot;</td>
<td class="tg-0pky">Cloneable is the marker Interface that indicates that clone() may be called on an object. Overriding <br /> clone() without implementing Cloneable can be useful if you want to control how subclasses clone themselves, but otherwise, <br /> it&#39;s probably a mistake. <br /> The usual convention for Object.clone() according to Oracle&#39;s Javadoc is: <br />  <br />    x.clone() != x  <br />    x.clone().getClass() == x.getClass()  <br />    x.clone().equals(x)  <br />  <br /> Obtaining the object that will be returned by calling super.clone() helps to satisfy those invariants: <br />  <br />    super.clone() returns a new object instance  <br />    super.clone() returns an object of the same type as the one clone() was called on  <br />    Object.clone() performs a shallow copy of the object&#39;s state  <br />  <br /> Noncompliant Code Example <br />  <br /> class BaseClass {  // Noncompliant; should implement Cloneable <br />   @Override <br />   public Object clone() throws CloneNotSupportedException {    // Noncompliant; should return the super.clone() instance <br />     return new BaseClass(); <br />   } <br /> } <br />  <br /> class DerivedClass extends BaseClass implements Cloneable { <br />   /<em> Does not override clone() </em>/ <br />  <br />   public void sayHello() { <br />     System.out.println(&quot;Hello, world!&quot;); <br />   } <br /> } <br />  <br /> class Application { <br />   public static void main(String[] args) throws Exception { <br />     DerivedClass instance = new DerivedClass(); <br />     ((DerivedClass) instance.clone()).sayHello();              // Throws a ClassCastException because invariant #2 is violated <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class BaseClass implements Cloneable { <br />   @Override <br />   public Object clone() throws CloneNotSupportedException {    // Compliant <br />     return super.clone(); <br />   } <br /> } <br />  <br /> class DerivedClass extends BaseClass implements Cloneable { <br />   /<em> Does not override clone() </em>/ <br />  <br />   public void sayHello() { <br />     System.out.println(&quot;Hello, world!&quot;); <br />   } <br /> } <br />  <br /> class Application { <br />   public static void main(String[] args) throws Exception { <br />     DerivedClass instance = new DerivedClass(); <br />     ((DerivedClass) instance.clone()).sayHello();              // Displays &quot;Hello, world!&quot; as expected. Invariant #2 is satisfied <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-580 - clone() Method Without super.clone()  <br />    CERT, MET53-J. - Ensure that the clone() method calls super.clone()  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Overriding methods should do more than simply call the same method in the super class</td>
<td class="tg-0pky">Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time <br /> this is justified is in final overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such <br /> overrides of equals, hashCode and toString. <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br />   super.doSomething(); <br /> } <br />  <br /> @Override <br /> public boolean isLegal(Action action) { <br />   return super.isLegal(action); <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public boolean isLegal(Action action) {         // Compliant - not simply forwarding the call <br />   return super.isLegal(new Action(/<em> ... </em>/)); <br /> } <br />  <br /> @Id <br /> @Override <br /> public int getId() {                            // Compliant - there is annotation different from @Override <br />   return super.getId(); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Nested code blocks should not be used</td>
<td class="tg-0pky">Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method <br /> typically indicates that the method has too many responsibilities, and should be refactored into smaller methods. <br /> Noncompliant Code Example <br />  <br /> public void evaluate(int operator) { <br />   switch (operator) { <br />     /<em> ... </em>/ <br />     case ADD: {                                // Noncompliant - nested code block &#39;{&#39; ... &#39;}&#39; <br />         int a = stack.pop(); <br />         int b = stack.pop(); <br />         int result = a + b; <br />         stack.push(result); <br />         break; <br />       } <br />     /<em> ... </em>/ <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void evaluate(int operator) { <br />   switch (operator) { <br />     /<em> ... </em>/ <br />     case ADD:                                  // Compliant <br />       evaluateAdd(); <br />       break; <br />     /<em> ... </em>/ <br />   } <br /> } <br />  <br /> private void evaluateAdd() { <br />   int a = stack.pop(); <br />   int b = stack.pop(); <br />   int result = a + b; <br />   stack.push(result); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">145</td>
</tr>
<tr>
<td class="tg-0pky">&quot;switch&quot; statements should have at least 3 &quot;case&quot; clauses</td>
<td class="tg-0pky">switch statements are useful when there are many different cases depending on the value of the same expression. <br /> For just one or two cases however, the code will be more readable with if statements. <br /> Noncompliant Code Example <br />  <br /> switch (variable) { <br />   case 0: <br />     doSomething(); <br />     break; <br />   default: <br />     doSomethingElse(); <br />     break; <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (variable == 0) { <br />   doSomething(); <br /> } else { <br />   doSomethingElse(); <br /> } <br />  <br /> See <br />  <br />    MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot;</td>
<td class="tg-0pky">The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. <br /> Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose <br /> type is a Java Collection interface. <br /> This rule raises an issue when an implementation class: <br />  <br />    is returned from a public method.  <br />    is accepted as an argument to a public method.  <br />    is exposed as a public member.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Employees { <br />   private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();  // Noncompliant - &quot;employees&quot; should have type &quot;Set&quot; rather than &quot;HashSet&quot; <br />  <br />   public HashSet&lt;Employee&gt; getEmployees() {                       // Noncompliant <br />     return employees; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Employees { <br />   private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();      // Compliant <br />  <br />   public Set&lt;Employee&gt; getEmployees() {                           // Compliant <br />     return employees; <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">20</td>
</tr>
<tr>
<td class="tg-0pky">Loops should not contain more than a single &quot;break&quot; or &quot;continue&quot; statement</td>
<td class="tg-0pky">Restricting the number of break and continue statements in a loop is done in the interest of good structured programming. <br />  <br /> One break and continue statement is acceptable in a loop, since it facilitates optimal coding. If there is more than one, <br /> the code should be refactored to increase readability. <br /> Noncompliant Code Example <br />  <br /> for (int i = 1; i &lt;= 10; i++) {     // Noncompliant - 2 continue - one might be tempted to add some logic in between <br />   if (i % 2 == 0) { <br />     continue; <br />   } <br />  <br />   if (i % 3 == 0) { <br />     continue; <br />   } <br />  <br />   System.out.println(&quot;i = &quot; + i); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">41</td>
</tr>
<tr>
<td class="tg-0pky">Private fields only used as local variables in methods should become local variables</td>
<td class="tg-0pky">When the value of a private field is always assigned to in a class&#39; methods before being read, then it is not being used to store class <br /> information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding. <br /> Noncompliant Code Example <br />  <br /> public class Foo { <br />   private int a; <br />   private int b; <br />  <br />   public void doSomething(int y) { <br />     a = y + 5; <br />     ... <br />     if(a == 0) { <br />       ... <br />     } <br />     ... <br />   } <br />  <br />   public void doSomethingElse(int y) { <br />     b = y + 3; <br />     ... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Foo { <br />  <br />   public void doSomething(int y) { <br />     int a = y + 5; <br />     ... <br />     if(a == 0) { <br />       ... <br />     } <br />   } <br />  <br />   public void doSomethingElse(int y) { <br />     int b = y + 3; <br />     ... <br />   } <br /> } <br />  <br /> Exceptions <br /> This rule doesn&#39;t raise any issue on annotated field.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">44</td>
</tr>
<tr>
<td class="tg-0pky">Unused local variables should be removed</td>
<td class="tg-0pky">If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will <br /> not wonder what the variable is used for. <br /> Noncompliant Code Example <br />  <br /> public int numberOfMinutes(int hours) { <br />   int seconds = 0;   // seconds is never used <br />   return hours <em> 60; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public int numberOfMinutes(int hours) { <br />   return hours </em> 60; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Local variables should not be declared and then immediately returned or thrown</td>
<td class="tg-0pky">Declaring a variable only to immediately return or throw it is a bad practice. <br /> Some developers argue that the practice improves code readability, because it enables them to explicitly name what is being returned. However, this <br /> variable is an internal implementation detail that is not exposed to the callers of the method. The method name should be sufficient for callers to <br /> know exactly what will be returned. <br /> Noncompliant Code Example <br />  <br /> public long computeDurationInMilliseconds() { <br />   long duration = (((hours <em> 60) + minutes) </em> 60 + seconds ) <em> 1000 ; <br />   return duration; <br /> } <br />  <br /> public void doSomething() { <br />   RuntimeException myException = new RuntimeException(); <br />   throw myException; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public long computeDurationInMilliseconds() { <br />   return (((hours </em> 60) + minutes) <em> 60 + seconds ) </em> 1000 ; <br /> } <br />  <br /> public void doSomething() { <br />   throw new RuntimeException(); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Strings should not be concatenated using &#39;+&#39; in a loop</td>
<td class="tg-0pky">Strings are immutable objects, so concatenation doesn&#39;t simply add the new String to the end of the existing string. Instead, in each loop <br /> iteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted <br /> back to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is <br /> preferred. <br /> Noncompliant Code Example <br />  <br /> String str = &quot;&quot;; <br /> for (int i = 0; i &lt; arrayOfStrings.length ; ++i) { <br />   str = str + arrayOfStrings[i]; <br /> } <br />  <br /> Compliant Solution <br />  <br /> StringBuilder bld = new StringBuilder(); <br />   for (int i = 0; i &lt; arrayOfStrings.length; ++i) { <br />     bld.append(arrayOfStrings[i]); <br />   } <br />   String str = bld.toString(); <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">12</td>
</tr>
<tr>
<td class="tg-0pky">Multiple variables should not be declared on the same line</td>
<td class="tg-0pky">Declaring multiple variables on one line is difficult to read. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   private int a, b; <br />  <br />   public void method(){ <br />     int c; int d; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   private int a; <br />   private int b; <br />  <br />   public void method(){ <br />     int c; <br />     int d; <br />   } <br /> } <br />  <br /> See <br />  <br />    MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator <br />   respectively  <br />    CERT, DCL52-J. - Do not declare more than one variable per declaration <br />    <br />    CERT, DCL04-C. - Do not declare more than one variable per declaration  <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Redundant casts should not be used</td>
<td class="tg-0pky">Unnecessary casting expressions make the code harder to read and understand. <br /> Noncompliant Code Example <br />  <br /> public void example() { <br />   for (Foo obj : (List&lt;Foo&gt;) getFoos()) {  // Noncompliant; cast unnecessary because List&lt;Foo&gt; is what&#39;s returned <br />     //... <br />   } <br /> } <br />  <br /> public List&lt;Foo&gt; getFoos() { <br />   return this.foos; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void example() { <br />   for (Foo obj : getFoos()) { <br />     //... <br />   } <br /> } <br />  <br /> public List&lt;Foo&gt; getFoos() { <br />   return this.foos; <br /> } <br />  <br /> Exceptions <br /> Casting may be required to distinguish the method to call in the case of overloading: <br />  <br /> class A {} <br /> class B extends A{} <br /> class C { <br />   void fun(A a){} <br />   void fun(B b){} <br />  <br />   void foo() { <br />     B b = new B(); <br />     fun(b); <br />     fun((A) b); //call the first method so cast is not redundant. <br />   } <br />  <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Subclasses that add fields should override &quot;equals&quot;</td>
<td class="tg-0pky">Extend a class that overrides equals and add fields without overriding equals in the subclass, and you run the risk of <br /> non-equivalent instances of your subclass being seen as equal, because only the superclass fields will be considered in the equality test. <br /> This rule looks for classes that do all of the following: <br />  <br />    extend classes that override equals.  <br />    do not themselves override equals.  <br />    add fields.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Fruit { <br />   private Season ripe; <br />  <br />   public boolean equals(Object obj) { <br />     if (obj == this) { <br />       return true; <br />     } <br />     if (this.class != obj.class) { <br />       return false; <br />     } <br />     Fruit fobj = (Fruit) obj; <br />     if (ripe.equals(fobj.getRipe()) { <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br />  <br /> public class Raspberry extends Fruit {  // Noncompliant; instances will use Fruit&#39;s equals method <br />   private Color ripeColor; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Fruit { <br />   private Season ripe; <br />  <br />   public boolean equals(Object obj) { <br />     if (obj == this) { <br />       return true; <br />     } <br />     if (this.class != obj.class) { <br />       return false; <br />     } <br />     Fruit fobj = (Fruit) obj; <br />     if (ripe.equals(fobj.getRipe()) { <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br />  <br /> public class Raspberry extends Fruit { <br />   private Color ripeColor; <br />  <br />   public boolean equals(Object obj) { <br />     if (! super.equals(obj)) { <br />       return false; <br />     } <br />     Raspberry fobj = (Raspberry) obj; <br />     if (ripeColor.equals(fobj.getRipeColor()) {  // added fields are tested <br />       return true; <br />     } <br />     return false; <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">10</td>
</tr>
<tr>
<td class="tg-0pky">Nested &quot;enum&quot;s should not be declared static</td>
<td class="tg-0pky">According to the docs: <br />  <br />   Nested enum types are implicitly <br />   static. <br />  <br /> So there&#39;s no need to declare them static explicitly. <br /> Noncompliant Code Example <br />  <br /> public class Flower { <br />   static enum Color { // Noncompliant; static is redundant here <br />     RED, YELLOW, BLUE, ORANGE <br />   } <br />  <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Flower { <br />   enum Color { // Compliant <br />     RED, YELLOW, BLUE, ORANGE <br />   } <br />  <br />   // ... <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Static non-final field names should comply with a naming convention</td>
<td class="tg-0pky">Shared naming conventions allow teams to collaborate efficiently. This rule checks that static non-final field names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public final class MyClass { <br />    private static String foo_bar; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private static String fooBar; <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">22</td>
</tr>
<tr>
<td class="tg-0pky">Abstract methods should not be redundant</td>
<td class="tg-0pky">There&#39;s no point in redundantly defining an abstract method with the same signature as a method in an interface that the <br /> class implements. Any concrete child classes will have to implement the method either way. <br /> Noncompliant Code Example <br />  <br /> public interface Reportable { <br />   String getReport(); <br /> } <br />  <br /> public abstract class AbstractRuleReport implements Reportable{ <br />   public abstract String getReport();  // Noncompliant <br />  <br />   // ... <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;private&quot; methods called only by inner classes should be moved to those classes</td>
<td class="tg-0pky">When a private method is only invoked by an inner class, there&#39;s no reason not to move it into that class. It will still have the same <br /> access to the outer class&#39; members, but the outer class will be clearer and less cluttered. <br /> Noncompliant Code Example <br />  <br /> public class Outie { <br />   private int i=0; <br />  <br />   private void increment() {  // Noncompliant <br />     i++; <br />   } <br />  <br />   public class Innie { <br />     public void doTheThing() { <br />       Outie.this.increment(); <br />     } <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Outie { <br />   private int i=0; <br />  <br />   public class Innie { <br />     public void doTheThing() { <br />       Outie.this.increment(); <br />     } <br />  <br />     private void increment() { <br />       Outie.this.i++; <br />     } <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">11</td>
</tr>
<tr>
<td class="tg-0pky">Methods should not return constants</td>
<td class="tg-0pky">There&#39;s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a <br /> method call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.  <br /> This rule raises an issue if on methods that contain only one statement: the return of a constant value.  <br /> Noncompliant Code Example <br />  <br /> int getBestNumber() { <br />   return 12;  // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> static int bestNumber = 12; <br />  <br /> Exceptions <br /> Methods with annotations, such as @Override and Spring&#39;s @RequestMapping, are ignored.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Loggers should be named for their enclosing classes</td>
<td class="tg-0pky">It is convention to name each class&#39;s logger for the class itself. Doing so allows you to set up clear, communicative logger configuration. Naming <br /> loggers by some other convention confuses configuration, and using the same class name for multiple class loggers prevents the granular configuration <br /> of each class&#39; logger. Some libraries, such as SLF4J warn about this, but not all do. <br /> This rule raises an issue when a logger is not named for its enclosing class. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private final static Logger LOG = LoggerFactory.getLogger(WrongClass.class);  // Noncompliant; multiple classes using same logger <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   private final static Logger LOG = LoggerFactory.getLogger(MyClass.class); <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Jump statements should not be redundant</td>
<td class="tg-0pky">Jump statements such as return and continue let you change the default flow of program execution, but jump statements <br /> that direct the control flow to the original direction are just a waste of keystrokes. <br /> Noncompliant Code Example <br />  <br /> public void foo() { <br />   while (condition1) { <br />     if (condition2) { <br />       continue; // Noncompliant <br />     } else { <br />       doTheThing(); <br />     } <br />   } <br />   return; // Noncompliant; this is a void method <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo() { <br />   while (condition1) { <br />     if (!condition2) { <br />       doTheThing(); <br />     } <br />   } <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">40</td>
</tr>
<tr>
<td class="tg-0pky">Arrays should not be created for varargs parameters</td>
<td class="tg-0pky">There&#39;s no point in creating an array solely for the purpose of passing it as a varargs (...) argument; varargs is an array. <br /> Simply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where Object ... <br /> is expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects? <br /> Noncompliant Code Example <br />  <br /> public void callTheThing() { <br />   //... <br />   doTheThing(new String[] { &quot;s1&quot;, &quot;s2&quot;});  // Noncompliant: unnecessary <br />   doTheThing(new String[12]);  // Compliant <br />   doTheOtherThing(new String[8]);  // Noncompliant: ambiguous <br />   // ... <br /> } <br />  <br /> public void doTheThing (String ... args) { <br />   // ... <br /> } <br />  <br /> public void doTheOtherThing(Object ... args) { <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void callTheThing() { <br />   //... <br />   doTheThing(&quot;s1&quot;, &quot;s2&quot;); <br />   doTheThing(new String[12]); <br />   doTheOtherThing((Object[]) new String[8]); <br />    // ... <br /> } <br />  <br /> public void doTheThing (String ... args) { <br />   // ... <br /> } <br />  <br /> public void doTheOtherThing(Object ... args) { <br />   // ... <br /> } <br /></td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">Packages containing only &quot;package-info.java&quot; should be removed</td>
<td class="tg-0pky">There is no reason to have a package that is empty except for &quot;package-info.java&quot;. Such packages merely clutter a project, taking up space but <br /> adding no value.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">1</td>
</tr>
<tr>
<td class="tg-0pky">&quot;write(byte[],int,int)&quot; should be overridden</td>
<td class="tg-0pky">When directly subclassing java.io.OutputStream or java.io.FilterOutputStream, the only requirement is that you implement <br /> the method write(int). However most uses for such streams don&#39;t write a single byte at a time and the default implementation for <br /> write(byte[],int,int) will call write(int) for every single byte in the array which can create a lot of overhead and is <br /> utterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of <br /> write(byte[],int,int). <br /> This rule raises an issue when a direct subclass of java.io.OutputStream or java.io.FilterOutputStream doesn&#39;t provide an <br /> override of write(byte[],int,int). <br /> Noncompliant Code Example <br />  <br /> public class MyStream extends OutputStream { // Noncompliant <br />     private FileOutputStream fout; <br />  <br />     public MyStream(File file) throws IOException { <br />         fout = new FileOutputStream(file); <br />     } <br />  <br />     @Override <br />     public void write(int b) throws IOException { <br />         fout.write(b); <br />     } <br />  <br />     @Override <br />     public void close() throws IOException { <br />         fout.write(&quot;\n\n&quot;.getBytes()); <br />         fout.close(); <br />         super.close(); <br />     } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyStream extends OutputStream { <br />     private FileOutputStream fout; <br />  <br />     public MyStream(File file) throws IOException { <br />         fout = new FileOutputStream(file); <br />     } <br />  <br />     @Override <br />     public void write(int b) throws IOException { <br />         fout.write(b); <br />     } <br />  <br />     @Override <br />     public void write(byte[] b, int off, int len) throws IOException { <br />         fout.write(b, off, len); <br />     } <br />  <br />     @Override <br />     public void close() throws IOException { <br />         fout.write(&quot;\n\n&quot;.getBytes()); <br />         fout.close(); <br />         super.close(); <br />     } <br /> } <br />  <br /> Exceptions <br /> This rule doesn&#39;t raise an issue when the class is declared abstract.</td>
<td class="tg-0pky">CODE_SMELL</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">2</td>
</tr>
<tr>
<td class="tg-0pky">Class variable fields should not have public accessibility</td>
<td class="tg-0pky">Public class variable fields do not respect the encapsulation principle and has three main disadvantages: <br />  <br />    Additional behavior such as validation cannot be added.  <br />    The internal representation is exposed, and cannot be changed afterwards.  <br />    Member values are subject to change from anywhere in the code and may not meet the programmer&#39;s assumptions.  <br />  <br /> By using private attributes and accessor methods (set and get), unauthorized modifications are prevented. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   public String firstName;                       // Noncompliant <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   private String firstName;                      // Compliant <br />  <br />   public String getFirstName() { <br />     return firstName; <br />   } <br />  <br />   public void setFirstName(String firstName) { <br />     this.firstName = firstName; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> Because they are not modifiable, this rule ignores public final fields. <br /> See <br />  <br />    MITRE, CWE-493 - Critical Public Variable Without Final Modifier  <br /></td>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">193</td>
</tr>
<tr>
<td class="tg-0pky">&quot;public static&quot; fields should be constant</td>
<td class="tg-0pky">There is no good reason to declare a field &quot;public&quot; and &quot;static&quot; without also declaring it &quot;final&quot;. Most of the time this is a kludge to share a <br /> state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to <br /> null.  <br /> Noncompliant Code Example <br />  <br /> public class Greeter { <br />   public static Foo foo = new Foo(); <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Greeter { <br />   public static final Foo FOO = new Foo(); <br />   ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-500 - Public Static Field Not Marked Final  <br />    CERT OBJ10-J. - Do not use public static nonfinal fields  <br /></td>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">27</td>
</tr>
<tr>
<td class="tg-0pky">Mutable fields should not be &quot;public static&quot;</td>
<td class="tg-0pky">There is no good reason to have a mutable object as the public (by default), static member of an interface. <br /> Such variables should be moved into classes and their visibility lowered.  <br /> Similarly, mutable static members of classes and enumerations which are accessed directly, rather than through getters and setters, <br /> should be protected to the degree possible. That can be done by reducing visibility or making the field final if appropriate.  <br /> Note that making a mutable field, such as an array, final will keep the variable from being reassigned, but doing so has no effect on <br /> the mutability of the internal state of the array (i.e. it doesn&#39;t accomplish the goal). <br /> This rule raises issues for public static array, Collection, Date, and awt.Point members. <br /> Noncompliant Code Example <br />  <br /> public interface MyInterface { <br />   public static String [] strings; // Noncompliant <br /> } <br />  <br /> public class A { <br />   public static String [] strings1 = {&quot;first&quot;,&quot;second&quot;};  // Noncompliant <br />   public static String [] strings2 = {&quot;first&quot;,&quot;second&quot;};  // Noncompliant <br />   public static List&lt;String&gt; strings3 = new ArrayList&lt;&gt;();  // Noncompliant <br />   // ... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-582 - Array Declared Public, Final, and Static  <br />    MITRE, CWE-607 - Public Static Final Field References Mutable Object  <br />    CERT, OBJ01-J. - Limit accessibility of fields  <br />    CERT, OBJ13-J. - Ensure that references to mutable objects are not exposed <br />    <br /></td>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">39</td>
</tr>
<tr>
<td class="tg-0pky">&quot;enum&quot; fields should not be publicly mutable</td>
<td class="tg-0pky">enums are generally thought of as constant, but an enum with a public field or public setter is <br /> not only non-constant, but also vulnerable to malicious code. Ideally fields in an enum are private and set in the <br /> constructor, but if that&#39;s not possible, their visibility should be reduced as much as possible. <br /> Noncompliant Code Example <br />  <br /> public enum Continent { <br />  <br />   NORTH_AMERICA (23, 24709000), <br />   // ... <br />   EUROPE (50, 39310000); <br />  <br />   public int countryCount;  // Noncompliant <br />   private int landMass; <br />  <br />   Continent(int countryCount, int landMass) { <br />     // ... <br />   } <br />  <br />   public void setLandMass(int landMass) {  // Noncompliant <br />     this.landMass = landMass; <br />   } <br />  <br /> Compliant Solution <br />  <br /> public enum Continent { <br />  <br />   NORTH_AMERICA (23, 24709000), <br />   // ... <br />   EUROPE (50, 39310000); <br />  <br />   private int countryCount; <br />   private int landMass; <br />  <br />   Continent(int countryCount, int landMass) { <br />     // ... <br />   } <br /></td>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">3</td>
</tr>
<tr>
<td class="tg-0pky">Return values should not be ignored when they contain the operation status code</td>
<td class="tg-0pky">When the return value of a function call contain the operation status code, this value should be tested to make sure the operation completed <br /> successfully. <br /> This rule raises an issue when the return values of the following are ignored: <br />  <br />    java.io.File operations that return a status code (except mkdirs)  <br />    Iterator.hasNext()  <br />    Enumeration.hasMoreElements()  <br />    Lock.tryLock()  <br />    non-void Condition.await* methods  <br />    CountDownLatch.await(long, TimeUnit)  <br />    Semaphore.tryAcquire  <br />    BlockingQueue: offer, remove  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething(File file, Lock lock) { <br />   file.delete();  // Noncompliant <br />   // ... <br />   lock.tryLock(); // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(File file, Lock lock) { <br />   if (!lock.tryLock()) { <br />     // lock failed; take appropriate action <br />   } <br />   if (!file.delete()) { <br />     // file delete failed; take appropriate action <br />   } <br /> } <br />  <br /> See <br />  <br />    MISRA C:2004, 16.10 - If a function returns error information, then that error information shall be tested  <br />    MISRA C++:2008, 0-1-7 - The value returned by a function having a non-void return type that is not an overloaded operator shall always be used. <br />    <br />    MISRA C:2012, Dir. 4.7 - If a function returns error information, then that error information shall be tested  <br />    MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used  <br />    CERT, ERR33-C. - Detect and handle standard library errors  <br />    CERT, POS54-C. - Detect and handle POSIX library errors  <br />    CERT, EXP00-J. - Do not ignore values returned by methods  <br />    CERT, EXP12-C. - Do not ignore values returned by functions  <br />    CERT, FIO02-J. - Detect and handle file-related errors  <br />    MITRE, CWE-754 - Improper Check for Unusual Exceptional Conditions  <br /></td>
<td class="tg-0pky">VULNERABILITY</td>
<td class="tg-0pky">MINOR</td>
<td class="tg-0pky">18</td>
</tr>
</tbody>
</table>

</div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2009&#x2013;2019 <a href="http://www.waarp.fr">Waarp</a>.
All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
